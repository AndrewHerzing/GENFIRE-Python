<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>../GENFIRE_io</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><font color="green">def</font> readMAT(filename):<br>    <font color="green">import</font> scipy.io<br>    <font color="green">import</font> numpy as np<br>    <font color="green">import</font> os<br>    """<br>    * readMAT *<br><br>    Read projections <font color="green">from</font> a .mat file<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of Cali<font color="green">for</font>nia, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename: MATLAB file (.mat) containing projections<br>    :return: NumPy array containing projections<br>    """<br><br>    try: #try to open the projections as a stack<br>        projections = scipy.io.loadmat(filename)<br>        key = None<br>        <font color="green">for</font> k in projections.keys():<br>            <font color="green">if</font> k[0] != "_":<br>                key = k<br>                break<br><br>        projections = np.array(projections[key])<br>    except: ## -- figure out where error is thrown<br>         #check <font color="green">if</font> the projections are in individual files<br>        flag = True<br>        filename_base, file_extension = os.path.splitext(filename)<br>        projectionCount = 1<br>        <font color="green">while</font> flag: #first count the number of projections so the array can be initialized<br>            projectionCount = projectionCount<br>            nextFile = filename_base + str(projectionCount) + file_extension<br>            <font color="green">if</font> os.path.isfile(nextFile):<br>                projectionCount += 1<br>            else:<br>                flag = False<br><br><br>        ## open first projection to get dimensions<br>        pj = scipy.io.loadmat(filename_base + str(1) + file_extension)<br>        pj = pj[projections.keys()[0]]<br>        dims = np.shape(pj)<br>        #initialize projection array<br>        projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>        #now actually load in the t<font color="green">if</font>f images<br>        <font color="green">for</font> projNum in range(projectionCount):<br>            nextFile = filename_base + str(projNum) + file_extension<br>            pj = scipy.io.loadmat(filename_base + str(projNum) + file_extension)<br>            pj = pj[pj.keys()[0]]<br>            projections[:, :, projNum] = np.array(pj)<br><br>    return projections<br><br><br><font color="green">def</font> readTIFF(filename):<br>    """<br>    * readTIFF *<br><br>    Read (possibly multiple) TIFF images into a NumPy array<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of Cali<font color="green">for</font>nia, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename: Name of TIFF file or TIFF file basename to read. If the filename is a base then<br>    #       the images must begin with the string contained in filename followed by consecutive integers with<br>    #       no zero padding, i.e. foo1.t<font color="green">if</font>f, foo2.t<font color="green">if</font>f,..., foo275.t<font color="green">if</font>f<br>    :return: NumPy array containing projections<br>    """<br>    <font color="green">import</font> functools<br>    <font color="green">from</font> PIL <font color="green">import</font> Image<br>    <font color="green">import</font> os<br>    <font color="green">import</font> numpy as np<br>    <font color="green">from</font> multiprocessing <font color="green">import</font> Pool<br>    try:<br>        projections = np.array(Image.open(filename))<br>    except:<br>        flag = True<br>        filename_base, file_extension = os.path.splitext(filename)<br>        projectionCount = 1<br>        <font color="green">while</font> flag: #first count the number of projections so the array can be initialized<br>            projectionCount = projectionCount<br>            nextFile = filename_base + str(projectionCount) + file_extension<br>            <font color="green">if</font> os.path.isfile(nextFile):<br>                projectionCount += 1<br>            else:<br>                flag = False<br><br>        ## open first projection to get dimensions<br>        dims = np.shape(Image.open(filename_base + str(1) + file_extension))<br><br>        #initialize projection array<br>        projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>        pool = Pool(4)<br>        func = functools.partial(readInT<font color="green">if</font>fProjection, filename_base)<br>        pj = pool.map(func, range(projectionCount))<br>        <font color="green">for</font> j  in range(projectionCount):<br>            projections[:, :, j] = pj[j]<br>    return projections<br><br><font color="green">def</font> readInT<font color="green">if</font>fProjection(filename_base, fileNumber):<br>    """<br>    * readInT<font color="green">if</font>fProjection *<br><br>    Reads and returns a single TIFF image as a NumPy array<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of Cali<font color="green">for</font>nia, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename_base: Base filename of TIFF<br>    :param fileNumber: Image number<br>    :return: Image in a 2D NumPy array<br>    """<br>    <font color="green">from</font> PIL <font color="green">import</font> Image<br>    <font color="green">import</font> numpy as np<br>    nextFile = filename_base + str(fileNumber) + '.t<font color="green">if</font>'<br>    return np.array(Image.open(nextFile))<br><br><font color="green">def</font> readMRC(filename, dtype=float,order="C"):<br>    """<br>    * readMRC *<br><br>    Read in a volume in .mrc file <font color="green">for</font>mat. See http://bio3d.colorado.edu/imod/doc/mrc_<font color="green">for</font>mat.txt<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of Cali<font color="green">for</font>nia, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename: Filename of .mrc<br>    :return: NumPy array containing the .mrc data<br>    """<br>    <font color="green">import</font> numpy as np<br>    <font color="green">import</font> struct<br>    headerIntNumber = 56<br>    sizeof_int = 4<br>    headerCharNumber = 800<br>    sizeof_char = 1<br>    with open(filename,'rb') as fid:<br>        int_header = struct.unpack('=' + 'i'*headerIntNumber, fid.read(headerIntNumber * sizeof_int))<br>        char_header = struct.unpack('=' + 'c'*headerCharNumber, fid.read(headerCharNumber * sizeof_char))<br>        dimx, dimy, dimz, data_flag= int_header[:4]<br>        print "reading, ", dimx,dimy,dimz<br>        <font color="green">if</font> (data_flag == 0):<br>            datatype='u1'<br>        el<font color="green">if</font> (data_flag ==1):<br>            datatype='i1'<br>        el<font color="green">if</font> (data_flag ==2):<br>            datatype='f4'<br>        el<font color="green">if</font> (data_flag ==3):<br>            datatype='c'<br>        el<font color="green">if</font> (data_flag ==4):<br>            datatype='f4'<br>        el<font color="green">if</font> (data_flag ==6):<br>            datatype='u2'<br>        else:<br>            raise ValueError("No supported datatype found!\n")<br>        print dimx,dimy,dimz<br>        print datatype<br>        return np.<font color="green">from</font>file(file=fid, dtype=datatype,count=dimx*dimy*dimz).reshape((dimx,dimy,dimz),order=order).astype(dtype)<br><br><font color="green">def</font> writeMRC(filename, arr, datatype='f4'):<br>    """<br>    * writeMRC *<br><br>    Write a volume to .mrc file <font color="green">for</font>mat. See http://bio3d.colorado.edu/imod/doc/mrc_<font color="green">for</font>mat.txt<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of Cali<font color="green">for</font>nia, Los Angeles<br>    Copyright 2015-2016. All rights reserved<br><br>    :param filename: Filename of .mrc file to write<br>    :param arr: NumPy volume of data to write<br>    :param dtype: Type of data to write<br>    """<br>    <font color="green">import</font> numpy as np<br>    dimx, dimy, dimz = np.shape(arr)<br>    <font color="green">if</font> datatype != arr.dtype:<br>        arr = arr.astype(datatype)<br>    int_header = np.zeros(56,dtype='int32')<br><br>    <font color="green">if</font> (datatype == 'u1'):<br>        data_flag = 0<br>    el<font color="green">if</font> (datatype =='i1'):<br>        data_flag = 1<br>    el<font color="green">if</font> (datatype =='f4'):<br>        data_flag = 2<br>    el<font color="green">if</font> (datatype =='c'):<br>        data_flag = 3<br>    el<font color="green">if</font> (datatype =='f4'):<br>        data_flag = 4<br>    el<font color="green">if</font> (datatype =='u2'):<br>        data_flag = 6<br>    else:<br>        raise ValueError("No supported datatype found!\n")<br><br>    int_header[:4] = (dimx,dimy,dimz,data_flag)<br>    char_header = str(' '*800)<br>    with open(filename,'wb') as fid:<br>        fid.write(int_header.tobytes())<br>        fid.write(char_header)<br>        fid.write(arr.tobytes())</code></body>
    </html>