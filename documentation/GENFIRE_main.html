<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>../GENFIRE_main</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><font color="green">from</font> __future__ <font color="green">import</font> division<br><font color="green">import</font> numpy as np<br><font color="green">import</font> scipy.io as io<br><font color="green">import</font> matplotlib<br>matplotlib.use("Qt4Agg")<br># <font color="green">import</font> matplotlib.pyplot as plt<br># <font color="green">import</font> time<br><font color="green">import</font> GENFIRE as GENFIRE<br><br># <font color="green">import</font> misc<br><font color="green">import</font> sys<br><font color="green">import</font> os<br><font color="green">from</font> GENFIRE <font color="green">import</font> ReconstructionParameters<br><br><br><font color="green">def</font> GENFIRE_main_InteractivelySetParameters():<br>    #######################################################################################################################<br>    ############################################### User Parameters  ######################################################<br>    #######################################################################################################################<br><br>    # GENFIRE's reconstruction parameters can be edited here by the user and run interactively, any inputs provided<br>    # by either the command line or the GUI will override these momentarily<br><br>    # filename_projections = './data/projections.mat'  #filename of projections, which should be size NxNxN_projections where N_projections is the number of projections<br>    filename_projections = './data/projections.mat'  #filename of projections, which should be size NxNxN_projections where N_projections is the number of projections<br>    filename_angles = './data/angles.mat'  #angles can be either a 1xN_projections array containing a single tilt series, or 3xN_projections array containing 3 Euler angles <font color="green">for</font> each projections in the <font color="green">for</font>m [phi;theta;psi]<br>    filename_support = './data/support60.mat'  #NxNxN binary array spec<font color="green">if</font>ying a region of 1's in which the reconstruction can exist<br>    filename_initialObject = None  #initial object to use in reconstruction; set to None to provide no initial guess<br>    filename_results = 'GENFIRE_rec.mrc'  #filename to save results<br>    resolutionExtensionSuppressionState = 2 # 1) Turn on resolution extension/suppression, 2) No resolution extension/suppression, 3) Just resolution extension<br><br>    numIterations = 100  #number of iterations to run in iterative reconstruction<br>    oversamplingRatio = 3  #input projections will be padded internally to match this oversampling ratio. If you prepad your projections, set this to 1<br>    interpolationCutoffDistance = 0.7  #radius of spherical interpolation kernel (in pixels) within which to include measured datapoints<br>    doYouWantToDisplayFigure = True<br>    displayFigure = GENFIRE.DisplayFigure()<br>    displayFigure.DisplayFigureON = doYouWantToDisplayFigure<br>    calculateRFree = True<br><br><br>    reconstruction_parameters                                      = ReconstructionParameters()<br>    reconstruction_parameters.projectionFilename                  = filename_projections<br>    reconstruction_parameters.angleFilename                       = filename_angles<br>    reconstruction_parameters.supportFilename                     = filename_support<br>    reconstruction_parameters.interpolationCutoffDistance         = interpolationCutoffDistance<br>    reconstruction_parameters.numIterations                       = numIterations<br>    reconstruction_parameters.oversamplingRatio                   = oversamplingRatio<br>    reconstruction_parameters.displayFigure                        = displayFigure<br>    reconstruction_parameters.calculateRfree                       = calculateRFree<br>    reconstruction_parameters.resolutionExtensionSuppressionState = resolutionExtensionSuppressionState<br>    <font color="green">if</font> os.path.isfile(filename_results): # If a valid initial object was provided, use it<br>        reconstruction_parameters._initialObjectFilename           = filename_results<br><br>    GENFIRE_main(reconstruction_parameters)<br><br><font color="green">def</font> GENFIRE_main(reconstruction_parameters):<br><br>    filename_projections = reconstruction_parameters.projectionFilename<br>    filename_angles = reconstruction_parameters.angleFilename<br>    filename_support = reconstruction_parameters.supportFilename<br>    filename_results = reconstruction_parameters.resultsFilename<br>    numIterations = reconstruction_parameters.numIterations<br>    oversamplingRatio = reconstruction_parameters.oversamplingRatio<br>    interpolationCutoffDistance = reconstruction_parameters.interpolationCutoffDistance<br>    displayFigure = reconstruction_parameters.displayFigure<br>    resolutionExtensionSuppressionState = reconstruction_parameters.resolutionExtensionSuppressionState<br>    calculateRFree = reconstruction_parameters.calculateRfree<br>    <font color="green">if</font> reconstruction_parameters.isInitialObjectDefined:<br>            filename_initialObject = reconstruction_parameters.initialObjectFilename<br>    else:<br>        filename_initialObject = None<br><br>    # print "filename_projections = ", (filename_projections)<br>    # print "filename_angles = ", (filename_angles)<br>    # print "filename_support = ", (filename_support)<br>    # print "filename_results = ", (filename_results)<br>    # print "numIterations = ", (numIterations)<br>    # print "oversamplingRatio = ", (oversamplingRatio)<br>    # print "numIterations = ", (numIterations)<br>    # print "interpolationCutoffDistance = ", (interpolationCutoffDistance)<br>    # print "displayFigure = ", (displayFigure)<br>    # print "filename_initialObject = ", (filename_initialObject)<br>    # print "resolutionExtensionSuppressionState:", resolutionExtensionSuppressionState<br><br>    ### begin reconstruction ###<br>    projections = GENFIRE.loadProjections(filename_projections) # load projections into a 3D numpy array<br><br>    # get dimensions of array and determine the array size after padding<br>    dims = np.shape(projections)<br>    paddedDim = dims[0] * oversamplingRatio<br>    padding = int((paddedDim-dims[0])/2)<br><br>    # load the support, or generate one <font color="green">if</font> none was provided<br>    <font color="green">if</font> filename_support == "":<br>        support = np.ones((dims[0],dims[0],dims[0]),dtype=float)<br>    else:<br>        support = io.loadmat(filename_support); support = support[support.keys()[0]]<br><br>    displayFigure.reconstructionDisplayWindowSize = np.shape(support) # this is used to show the central region of reconstruction<br><br>    # now zero-pad to match the oversampling ratio<br>    support = np.pad(support,((padding,padding),(padding,padding),(padding,padding)),'constant')<br>    projections = np.pad(projections,((padding,padding),(padding,padding),(0,0)),'constant')<br><br>    #load initial object, or initialize it to zeros <font color="green">if</font> none was given<br>    <font color="green">if</font> filename_initialObject is not None and os.path.isfile(filename_initialObject):<br>        initialObject = GENFIRE.loadInitialObject(filename_initialObject)<br>        initialObject = np.pad(initialObject,((padding,padding),(padding,padding),(padding,padding)),'constant')<br>    else:<br>        initialObject = np.zeros_like(support)<br><br>    # load angles and check that the dimensions match the number of provided projections and that they<br>    # are either 1 x num_projections or 3 x num_projections<br>    angles = GENFIRE.loadAngles(filename_angles)<br>    <font color="green">if</font> np.shape(angles)[0] > 3:<br>        raise ValueError("GENFIRE: Error! Dimension of angles incorrect.")<br>    <font color="green">if</font> np.shape(angles)[0] == 1:<br>        tmp = np.zeros([3, np.shape(angles)[1]])<br>        tmp[1, :] = angles<br>        angles = tmp<br>        del tmp<br><br>    # grid the projections<br>    measuredK = GENFIRE.fillInFourierGrid(projections, angles, interpolationCutoffDistance)<br>    # the grid is assembled with the origin at the geometric center of the array, but <font color="green">for</font> efficiency in the<br>    # iterative algorithm the origin is sh<font color="green">if</font>ted to array position [0,0,0] to avoid unnecessary fftsh<font color="green">if</font>t calls<br>    measuredK = np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(measuredK)<br><br>    # create a map of the spatial frequency to be used to control resolution extension/suppression behavior<br>    K_indices = GENFIRE.generateKspaceIndices(support)<br>    K_indices = np.fft.fftsh<font color="green">if</font>t(K_indices)<br>    resolutionIndicators = np.zeros_like(K_indices)<br>    resolutionIndicators[measuredK != 0] = 1-K_indices[measuredK != 0]<br><br>    # <font color="green">if</font> calculating Rfree, setup some infrastructure<br>    <font color="green">if</font> calculateRFree:<br>        R_freeInd_complexX = []<br>        R_freeInd_complexY = []<br>        R_freeInd_complexZ = []<br>        R_freeVals_complex = []<br>        shell_thickness_pixels = 3 # pixel thickness of an individual shell of Rfree points<br>        numberOfBins = int(round(dims[0]/2/shell_thickness_pixels)) # number of frequency bins. Rfree will be tracked within each shell separately<br>        percentValuesForRfree = 0.05 # percentage of measured points to withhold<br>        spatialFrequencyForRfree = np.linspace(0,1,numberOfBins+1)<br>        K_indicesSmall =(K_indices)[:, :, 0:(np.shape(measuredK)[-1]//2+1)]<br><br>        <font color="green">for</font> shellNum in range(0,numberOfBins):<br>            # collect relevant points<br>            measuredPointInd_complex = np.where((measuredK[:, :, 0:(np.shape(measuredK)[-1]//2+1)] != 0) & (K_indicesSmall>=(spatialFrequencyForRfree[shellNum])) & (K_indicesSmall<=(spatialFrequencyForRfree[shellNum+1])))<br><br>            # randomly shuffle<br>            shuffledPoints = np.random.permutation(np.shape(measuredPointInd_complex)[1])<br>            measuredPointInd_complex = (measuredPointInd_complex[0][shuffledPoints], measuredPointInd_complex[1][shuffledPoints], measuredPointInd_complex[2][shuffledPoints])<br><br>            # determine how many values to take<br>            cutoffInd_complex = np.floor(np.shape(measuredPointInd_complex)[1] * percentValuesForRfree).astype(int)<br><br>            # collect the Rfree values and coordinates<br>            R_freeInd_complexX.append(measuredPointInd_complex[0][:cutoffInd_complex])<br>            R_freeInd_complexY.append(measuredPointInd_complex[1][:cutoffInd_complex])<br>            R_freeInd_complexZ.append(measuredPointInd_complex[2][:cutoffInd_complex])<br>            R_freeVals_complex.append(measuredK[R_freeInd_complexX[shellNum], R_freeInd_complexY[shellNum], R_freeInd_complexZ[shellNum] ])<br><br>            # delete the points <font color="green">from</font> the measured data<br>            measuredK[R_freeInd_complexX[shellNum], R_freeInd_complexY[shellNum], R_freeInd_complexZ[shellNum]] = 0<br><br>        # create tuple of coordinates<br>        R_freeInd_complex = [[R_freeInd_complexX], [R_freeInd_complexY], [R_freeInd_complexZ]]<br>        del R_freeInd_complexX<br>        del R_freeInd_complexY<br>        del R_freeInd_complexZ<br>    else:<br>        R_freeInd_complex = []<br>        R_freeVals_complex = []<br><br>    <font color="green">if</font> resolutionExtensionSuppressionState==1: # resolution extension/suppression<br>        constraintEn<font color="green">for</font>cementDelayIndicators = np.array(np.concatenate((np.arange(0.95, -.25, -0.15), np.arange(-0.15, .95, .1)), axis=0))<br>    el<font color="green">if</font> resolutionExtensionSuppressionState==2:# no resolution extension or suppression<br>        constraintEn<font color="green">for</font>cementDelayIndicators = np.array([-999, -999, -999, -999])<br>    el<font color="green">if</font> resolutionExtensionSuppressionState==3:# resolution extension only<br>        constraintEn<font color="green">for</font>cementDelayIndicators = np.concatenate((np.arange(0.95, -.15, -0.15),[-0.15, -0.15, -0.15]))<br>    else:<br>        print("GENFIRE: Warning! Input resolutionExtensionSuppressionState does not match an available option. Deactivating dynamic constraint en<font color="green">for</font>cement and continuing.\n")<br>        constraintEn<font color="green">for</font>cementDelayIndicators = np.array([-999, -999, -999, -999])<br><br>    reconstructionOutputs = GENFIRE.GENFIRE_iterate(numIterations,np.fft.fftsh<font color="green">if</font>t(initialObject),np.fft.fftsh<font color="green">if</font>t(support),(measuredK)[:, :, 0:(np.shape(measuredK)[-1]//2+1)],(resolutionIndicators)[:, :, 0:(np.shape(measuredK)[-1]//2+1)],constraintEn<font color="green">for</font>cementDelayIndicators,R_freeInd_complex,R_freeVals_complex,displayFigure)<br><br>    # reclaim original array size. ncBig is center of oversampled array, and n2 is the half-width of original array<br>    ncBig = paddedDim//2<br>    n2 = dims[0]//2<br>    reconstructionOutputs['reconstruction'] = reconstructionOutputs['reconstruction'][ncBig-n2:ncBig+n2,ncBig-n2:ncBig+n2,ncBig-n2:ncBig+n2]<br><br>    print ('GENFIRE: Reconstruction finished.')<br>    GENFIRE.saveResults(reconstructionOutputs, filename_results)<br>    # io.savemat(filename_results,reconstructionOutputs)<br><br><font color="green">if</font> __name__ == "<font color="green">__main__</font>" and len(sys.argv) == 1:<br>    print ("starting with user parameters")<br>    GENFIRE_main_InteractivelySetParameters()<br>el<font color="green">if</font> __name__ == "<font color="green">__main__</font>":<br>    <font color="green">if</font> len(sys.argv) > 1: # Parse inputs provided either <font color="green">from</font> the GUI or <font color="green">from</font> the command line<br>        inputArgumentOptions = {"-p" :  "filename_projections",<br>                                "-a" :  "filename_angles",<br>                                "-s" :  "filename_support",<br>                                "-o" :  "filename_results",<br>                                "-i" :  "filename_initialObject",<br>                                "-r" :  "resolutionExtensionSuppressionState",<br>                                "-it":  "numIterations",<br>                                "-or":  "oversamplingRatio",<br>                                "-t" :  "interpolationCutoffDistance",<br>                                "-d" :  "displayFigure",<br>                                "-rf":  "calculateRFree"<br>                                }<br>        print (sys.argv[:])<br>        <font color="green">if</font> len(sys.argv)%2==0:<br>            raise Exception("GENFIRE: Number of input options and input arguments does not match!")<br>        <font color="green">for</font> argumentNum in range(1,len(sys.argv),2):<br>            print (inputArgumentOptions[sys.argv[argumentNum]])<br>            print  (sys.argv[argumentNum+1])<br>            print (inputArgumentOptions[sys.argv[argumentNum]] + "=" + sys.argv[argumentNum+1])<br><br><br>            exec(inputArgumentOptions[sys.argv[argumentNum]] + "= '" + sys.argv[argumentNum+1] +"'")<br>            print("Setting argument %s <font color="green">from</font> option %s equal to GENFIRE parameter %s " % (sys.argv[argumentNum+1],sys.argv[argumentNum], inputArgumentOptions[sys.argv[argumentNum]] ))<br><br>        numIterations = int(numIterations)<br>        # displayFigure = bool(displayFigure)<br>        doYouWantToDisplayFigure = bool(displayFigure)<br>        displayFigure = GENFIRE.DisplayFigure()<br>        displayFigure.DisplayFigureON = doYouWantToDisplayFigure<br>        oversamplingRatio = float(oversamplingRatio)<br>        resolutionExtensionSuppressionState = int(resolutionExtensionSuppressionState)<br>        calculateRFree = bool(calculateRFree)<br>        try:<br>            GENFIRE_main(filename_projections,<br>                         filename_angles,<br>                         filename_support,<br>                         filename_results,<br>                         numIterations,<br>                         oversamplingRatio,<br>                         interpolationCutoffDistance,<br>                         resolutionExtensionSuppressionState,<br>                         displayFigure,<br>                         calculateRFree,<br>                         filename_initialObject)<br>        except (NameError, IOError):<br>             GENFIRE_main(filename_projections,<br>                          filename_angles,<br>                          filename_support,<br>                          filename_results,<br>                          numIterations,<br>                          oversamplingRatio,<br>                          interpolationCutoffDistance,<br>                          resolutionExtensionSuppressionState,<br>                          displayFigure,<br>                          calculateRFree)<br><br></code></body>
    </html>