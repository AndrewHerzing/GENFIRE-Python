<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>..//GENFIRE/fileio</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><font color="orange">import </font>numpy as np<br><br><font color="orange">def </font>loadVolume(filename):<br>    <font color="orange">import </font>os<br>    base, ext = os.path.splitext(filename)<br>    <font color="orange">if </font>(ext == ".mrc"):<br>        return readMRC(filename)<br>    <font color="orange">el<font color="orange">if </font></font>(ext == ".mat"):<br>        return readMAT_volume(filename)<br>    <font color="orange">el<font color="orange">if </font></font>(ext == ".npy"):<br>        return np.load(filename)<br><br><font color="orange">def </font>readMAT_volume(filename):<br>    <font color="orange">import </font>numpy as np<br>    <font color="orange">import </font>scipy.io<br>    data = scipy.io.loadmat(filename)<br>    var_name = [key <font color="orange">for </font>key in data <font color="orange">if </font>not key.startswith("__")]<br>    <font color="orange">if </font>len(var_name) > 1:<br>        raise IOError("Only 1 variable allowed per .MAT file")<br>    else:<br>        return np.array(data[var_name[0]])<br><br><font color="orange">def </font>readNPY(filename, dtype=float, order="C"):<br>    <font color="orange">import </font>numpy as np<br>    return np.load(filename)<br><br><font color="orange">def </font>readMRC(filename, dtype=float, order="C"):<br>    """<br>    * readMRC *<br><br>    Read in a volume in .mrc file format. See http://bio3d.colorado.edu/imod/doc/mrc_format.txt<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename: Filename of .mrc<br>    :return: NumPy array containing the .mrc data<br>    """<br>    import numpy as np<br>    import struct<br>    headerIntNumber = 56<br>    sizeof_int = 4<br>    headerCharNumber = 800<br>    sizeof_char = 1<br>    with open(filename,'rb') as fid:<br>        int_header = struct.unpack('=' + 'i'*headerIntNumber, fid.read(headerIntNumber * sizeof_int))<br>        char_header = struct.unpack('=' + 'c'*headerCharNumber, fid.read(headerCharNumber * sizeof_char))<br>        dimx, dimy, dimz, data_flag= int_header[:4]<br>        if (data_flag == 0):<br>            datatype='u1'<br>        elif (data_flag ==1):<br>            datatype='i1'<br>        elif (data_flag ==2):<br>            datatype='f4'<br>        elif (data_flag ==3):<br>            datatype='c'<br>        elif (data_flag ==4):<br>            datatype='f4'<br>        elif (data_flag ==6):<br>            datatype='u2'<br>        else:<br>            raise ValueError("No supported datatype found!\n")<br><br>        return np.fromfile(file=fid, dtype=datatype,count=dimx*dimy*dimz).reshape((dimx,dimy,dimz),order=order).astype(dtype)<br><br>def writeMRC(filename, arr, datatype='f4', order="C"):<br>    """<br>    * writeMRC *<br><br>    Write a volume to .mrc file format. See http://bio3d.colorado.edu/imod/doc/mrc_format.txt<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved<br><br>    :param filename: Filename of .mrc file to write<br>    :param arr: NumPy volume of data to write<br>    :param dtype: Type of data to write<br>    """<br>    import numpy as np<br><br>    dimx, dimy, dimz = np.shape(arr)<br><br>    # if order=='F':<br>    #     arr = np.transpose(arr)<br><br>    if datatype != arr.dtype:<br>        arr = arr.astype(datatype)<br>    int_header = np.zeros(56,dtype='int32')<br><br>    if (datatype == 'u1'):<br>        data_flag = 0<br>    elif (datatype =='i1'):<br>        data_flag = 1<br>    elif (datatype =='f4'):<br>        data_flag = 2<br>    elif (datatype =='c'):<br>        data_flag = 3<br>    elif (datatype =='f4'):<br>        data_flag = 4<br>    elif (datatype =='u2'):<br>        data_flag = 6<br>    else:<br>        raise ValueError("No supported datatype found!\n")<br><br>    int_header[:4] = (dimx,dimy,dimz,data_flag)<br>    char_header = str(' '*800)<br>    with open(filename,'wb') as fid:<br>        fid.write(int_header.tobytes())<br>        fid.write(char_header)<br>        fid.write(arr.tobytes(order=order))<br><br><br>def loadProjections(filename):<br>    """<br>    * loadProjections *<br><br>    Wrapper function for loading in projections of arbitrary (supported) extension<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename: Filename of images to load<br>    :return: NumPy array containing projections<br>    """<br>    import os<br>    filename, file_extension = os.path.splitext(filename)<br>    if file_extension == ".mat":<br>        print ("Reading projections from MATLAB file.\n")<br>        # return readMAT_projections(filename + file_extension)<br>        return readMAT_volume(filename + file_extension)<br>    elif file_extension == ".tif":<br>        print ("Reading projections from .tif file.\n")<br>        return readTIFF_projections(filename + file_extension)<br>    elif file_extension == ".mrc":<br>        print ("Reading projections from .mrc file.\n")<br>        return readMRC(filename + file_extension)<br>    elif file_extension == ".npy":<br>        print ("Reading projections from .npy file.\n")<br>        return readNPY(filename + file_extension)<br>    else:<br>        raise Exception('File format %s not supported.', file_extension)<br><br>def readMAT_projections(filename):<br>    import scipy.io<br>    import numpy as np<br>    import os<br>    """<br>    * readMAT *<br><br>    Read projections from a .mat file<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename: MATLAB file (.mat) containing projections<br>    :return: NumPy array containing projections<br>    """<br><br>    try: #try to open the projections as a stack<br>        projections = scipy.io.loadmat(filename)<br>        key = None<br>        for k in projections.keys():<br>            if k[0] != "_":<br>                key = k<br>                break<br><br>        projections = np.array(projections[key])<br>    except: ## -- figure out where error is thrown<br>         #check if the projections are in individual files<br>        flag = True<br>        filename_base, file_extension = os.path.splitext(filename)<br>        projectionCount = 1<br>        while flag: #first count the number of projections so the array can be initialized<br>            projectionCount = projectionCount<br>            nextFile = filename_base + str(projectionCount) + file_extension<br>            if os.path.isfile(nextFile):<br>                projectionCount += 1<br>            else:<br>                flag = False<br><br><br>        ## open first projection to get dimensions<br>        pj = scipy.io.loadmat(filename_base + str(1) + file_extension)<br>        pj = pj[projections.keys()[0]]<br>        dims = np.shape(pj)<br>        #initialize projection array<br>        projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>        #now actually load in the tiff images<br>        for projNum in range(projectionCount):<br>            nextFile = filename_base + str(projNum) + file_extension<br>            pj = scipy.io.loadmat(filename_base + str(projNum) + file_extension)<br>            pj = pj[pj.keys()[0]]<br>            projections[:, :, projNum] = np.array(pj)<br><br>    return projections<br><br><br>def readTIFF_projections(filename):<br>    """<br>    * readTIFF *<br><br>    Read (possibly multiple) TIFF images into a NumPy array<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename: Name of TIFF file or TIFF file basename to read. If the filename is a base then<br>    #       the images must begin with the string contained in filename followed by consecutive integers with<br>    #       no zero padding, i.e. foo1.tiff, foo2.tiff,..., foo275.tiff<br>    :return: NumPy array containing projections<br>    """<br>    import functools<br>    from PIL import Image<br>    import os<br>    import numpy as np<br>    from multiprocessing import Pool<br>    try:<br>        projections = np.array(Image.open(filename))<br>    except:<br>        flag = True<br>        filename_base, file_extension = os.path.splitext(filename)<br>        projectionCount = 1<br>        while flag: #first count the number of projections so the array can be initialized<br>            projectionCount = projectionCount<br>            nextFile = filename_base + str(projectionCount) + file_extension<br>            if os.path.isfile(nextFile):<br>                projectionCount += 1<br>            else:<br>                flag = False<br><br>        ## open first projection to get dimensions<br>        dims = np.shape(Image.open(filename_base + str(1) + file_extension))<br><br>        #initialize projection array<br>        projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>        pool = Pool(4)<br>        func = functools.partial(readInTiffProjection, filename_base)<br>        pj = pool.map(func, range(projectionCount))<br>        for j  in range(projectionCount):<br>            projections[:, :, j] = pj[j]<br>    return projections<br><br>def readInTiffProjection(filename_base, fileNumber):<br>    """<br>    * readInTiffProjection *<br><br>    Reads and returns a single TIFF image as a NumPy array<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename_base: Base filename of TIFF<br>    :param fileNumber: Image number<br>    :return: Image in a 2D NumPy array<br>    """<br>    from PIL import Image<br>    import numpy as np<br>    nextFile = filename_base + str(fileNumber) + '.tif'<br>    return np.array(Image.open(nextFile))<br><br>def loadAngles(filename):<br>    """<br>    * loadAngles *<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename:<br>    :return:<br>    """<br>    import os<br>    base,ext = os.path.splitext(filename)<br>    ext = ext.lower()<br>    if ext == ".txt":<br>        return np.loadtxt(filename,dtype=float)<br>    elif ext== ".npy":<br>        return np.load(filename)<br>    elif ext==".mat":<br>        import scipy.io<br>        data = scipy.io.loadmat(filename)<br>        if "angles" not in data.keys():<br>            raise LookupError("No variable called 'angles' found in \"{}\"!".format(filename))<br>        return np.array(data['angles'],dtype=float)<br>    else:<br>        raise IOError("Unsupported file extension \"{}\" for Euler angles".format(ext))<br><br>def loadInitialObject(filename):<br>    """<br>    * loadInitialObject *<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename:<br>    :return:<br>    """<br>    import os<br>    base,ext = os.path.splitext(filename)<br>    ext = ext.lower()<br>    if ext == ".npy":<br>        return np.load(filename)<br>    elif ext==".mat":<br>        import scipy.io<br>        data = scipy.io.loadmat(filename)<br>        if "initial_object" not in data.keys():<br>            raise LookupError("No variable called 'initial_object' found in \"{}\"!".format(filename))<br>        return np.array(data['initial_object'],dtype=float)<br>    elif ext==".mrc":<br>        raise NotImplementedError("mrc file format not yet supported")<br>    else:<br>        raise IOError("Unsupported file extension \"{}\" for initial object".format(ext))<br><br>def saveResults(reconstruction_outputs, filename):<br>    """<br>    * saveResults *<br><br>    Helper function to save results of GENFIRE reconstruction<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved<br><br>    :param reconstruction_outputs: dictionary containing reconstruction, reciprocal error (errK), and possible R_free<br>    :param filename: Output filename<br>    """<br>    import os<br>    fn, ext = os.path.splitext(filename)<br>    saveData(filename, reconstruction_outputs['reconstruction'])<br>    np.savetxt(fn+'_errK.txt',reconstruction_outputs['errK'])<br>    if 'R_free' in reconstruction_outputs.keys():<br>        np.savetxt(fn+'_Rfree.txt',reconstruction_outputs['R_free'])<br><br>def saveData(filename, data):<br>    import os<br>    fn, ext = os.path.splitext(filename)<br>    if ext == ".mrc":<br>        writeMRC(filename, data, order="C")<br>    elif ext == ".npy":<br>        import numpy as np<br>        np.save(filename,data)<br>    elif ext == ".mat":<br>        import scipy.io<br>        scipy.io.savemat(filename, {"data":data})<br>    else:<br>        raise IOError("Unsupported file extension \"{}\" for initial object".format(ext))<br></code></body>
    </html>