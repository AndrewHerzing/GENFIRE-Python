<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>..//GENFIRE/utility</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code>"""<br>* GENFIRE.utility *<br><br>This module contains various useful functions that do not fit into another category<br><br><br>Author: Alan (AJ) Pryor, Jr.<br>Jianwei (John) Miao Coherent Imaging Group<br>University of California, Los Angeles<br>Copyright 2015-2016. All rights reserved.<br>"""<br><br><br><font color="orange">from </font>__future__ <font color="orange">import </font>division<br><font color="orange">import </font>numpy as np<br><font color="orange">import </font>pyfftw<br><font color="orange">from </font>scipy.interpolate <font color="orange">import </font>RegularGridInterpolator<br>PI = np.pi<br><br><font color="orange">def </font>hermitianSymmetrize(volume):<br>    """<br>    * hermitianSymmetrize *<br><br>    Enforce Hermitian symmetry to volume<br><br>    :param volume: 3D volume to symmetrize<br>    :return: symmetrized volume<br>    <br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright (c) 2016. All Rights Reserved.<br>    """<br><br>    startDims = np.shape(volume) # initial dimensions<br><br>    # remember the initial dimensions for the end<br>    dimx = startDims[0]<br>    dimy = startDims[1]<br>    dimz = startDims[2]<br>    flag = <font color="orange">False </font># flag to trigger copying to new odd dimensioned array<br><br>    #check if any dimension is odd<br>    <font color="orange">if </font>dimx % 2 == 0:<br>        dimx += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>dimy % 2 == 0:<br>        dimy += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>dimz % 2 == 0:<br>        dimz += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>flag: # if any dimensions are even, create a new with all odd dimensions and copy volume<br>        newInput = np.zeros((dimx,dimy,dimz), dtype=complex) #new array<br>        newInput[:startDims[0], :startDims[1], :startDims[2]] = volume # copy values<br>        numberOfValues = (newInput != 0).astype(float) #track number of values for averaging<br>        newInput = newInput + np.conj(newInput[::-1, ::-1, ::-1]) # combine Hermitian symmetry mates<br>        numberOfValues = numberOfValues + numberOfValues[::-1, ::-1, ::-1] # track number of points included in each sum<br><br>        newInput[numberOfValues != 0] /= numberOfValues[numberOfValues != 0] # take average where two values existed<br>        newInput[np.isnan(newInput)] = 0 # Shouldn't be any nan, but just to be safe<br><br>        return newInput[:startDims[0], :startDims[1], :startDims[2]] # return original dimensions<br><br><br>    else: # otherwise, save yourself the trouble of copying the matrix over. See previous comments for line-by-line<br>        numberOfValues = (volume != 0).astype(int)<br>        volume += np.conjugate(volume[::-1, ::-1, ::-1])<br>        numberOfValues += numberOfValues[::-1, ::-1, ::-1]<br>        volume[numberOfValues != 0] /= numberOfValues[numberOfValues != 0]<br>        volume[np.isnan(volume)] = 0<br>        return volume<br><br><br><font color="orange">def </font>smooth3D(object,resolutionCutoff):<br>    """<br>    * smooth3D *<br><br>    Low pass filter a 3D volume<br><br>    :param object: 3D volume<br>    :param resolutionCutoff: Fraction of Nyquist frequency to use as sigma for the Gaussian filter<br>    :return: smoothed volume<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright (c) 2016. All Rights Reserved.<br>    """<br>    dims = np.shape(object)<br>    <font color="orange">if </font>dims[2] == 1:<br>        raise Exception('This is not a 3D object, use smooth2D instead.')<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # These  next few lines are easier to read, but in the actual code I just directly<br>    # place the np.arange terms in to avoid creating unnecessary variables<br>    # Xvec = np.arange(0,dims[0])-Xcenter<br>    # Yvec = np.arange(0,dims[1])-Ycenter<br>    # Zvec = np.arange(0,dims[2])-Zcenter<br>    # xx, yy, zz = np.meshgrid(Xvec, Yvec, Zvec)<br><br>    xx, yy, zz = np.meshgrid(np.arange(0,dims[0])-Xcenter, np.arange(0,dims[1])-Ycenter, np.arange(0,dims[2])-Zcenter)<br>    sigma  = dims[0]/2*resolutionCutoff<br><br>    #construct the filter and normalize<br>    K_filter = np.exp(-(((xx)**2 + (yy)**2 + (zz) **2)/(2*sigma*sigma)))<br>    K_filter /= np.max(np.max(np.max(abs(K_filter))))<br><br>    # take FFT and multiply by filter<br>    kbinned = pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.fftn(object,overwrite_input=True)) * K_filter<br><br>    # Assuming the input is real, the output will be approximately real, but will have some<br>    # tiny imaginary part due to rounding errors. This function would work for smoothing a<br>    # complex object, but this return statement would need to be modified<br>    return np.real(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(kbinned)))<br><br><br><br><br><font color="orange">def </font>smooth2D(object,resolutionCutoff):<br>    """<br>    * smooth2D *<br><br>    Low pass filter a 2D image<br><br>    :param object: 2D image<br>    :param resolutionCutoff: Fraction of Nyquist frequency to use as sigma for the Gaussian filter<br>    :return: smoothed image<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright (c) 2016. All Rights Reserved.<br>    """<br>    dims = np.shape(object)<br>    <font color="orange">if </font>len(dims)>2:<br>        raise Exception('This is a 3D object, use smooth3D instead.')<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br><br>    # These  next few lines are easier to read, but in the actual code I just directly<br>    # place the np.arange terms in to avoid creating unnecessary variables<br>    # Xvec = np.arange(0,dims[0])-Xcenter<br>    # Yvec = np.arange(0,dims[1])-Ycenter<br>    # xx, yy = np.meshgrid(Xvec, Yvec)<br><br>    xx, yy = np.meshgrid(np.arange(0,dims[0])-Xcenter, np.arange(0,dims[1])-Ycenter)<br>    sigma  = dims[0]/2*resolutionCutoff<br><br>    #construct the filter and normalize<br>    K_filter = np.exp(-(((xx)**2 + (yy)**2)/(2*sigma*sigma)))<br>    K_filter /= np.max(np.max(np.max(abs(K_filter))))<br><br>    # take FFT and multiply by filter<br>    kbinned =  pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.fftn(object,overwrite_input=True)) * K_filter<br><br>    # Assuming the input is real, the output will be approximately real, but will have some<br>    # tiny imaginary part due to rounding errors. This function would work for smoothing a<br>    # complex object, but this return statement would need to be modified<br>    return np.real(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(kbinned)))<br><br><br><br><font color="orange">def </font>calculateProjection_interp(modelK, phi, theta, psi):<br>    """<br>    * calculateProjection_interp *<br><br>    Calculate a projection of a 3D volume from it's oversampled Fourier transform by interpolating<br>    the central slice at the orientation determined by Euler angles (phi, theta, psi)<br><br>    :param modelK: numpy array holding the oversampled FFT of the model<br>    :param phi: euler angle 1<br>    :param theta: euler angle 2<br>    :param psi: euler angle 3<br>    :return: projection<br>    """<br><br>    # projection = None<br>    dims = np.shape(modelK)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # X, Y, Z = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), 0)<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    # build coordinates of 3D FFT<br>    # kx, ky, kz = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), np.arange(1,dims[2]-Zcenter))<br><br>    kx = np.arange(0, dims[0])-Xcenter<br>    ky = np.arange(0, dims[1])-Ycenter<br>    kz = np.arange(0, dims[2])-Zcenter<br><br>    # construct interpolator function that does the actual computation<br>    interpolator = RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br><br>    # build coordinates of the slice we want to calculate<br>    kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(kx_slice)])<br>    rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>    rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>    rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    projection = interpolator(rotKCoords.T)<br>    projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br><br><br>    return np.real(pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(projection))))<br><br><br><font color="orange">def </font>getProjectionInterpolator(modelK):<br>    """<br>    * generateKspaceIndices *<br><br>    Maps the radial coordinate indices in the matrix obj<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br><br>    :param obj: Matrix of size to be mapped<br>    :return: 3D indices for each voxel in the volume<br>    """<br>    dims = np.shape(modelK)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    kx = np.arange(0, dims[0])-Xcenter<br>    ky = np.arange(0, dims[1])-Ycenter<br>    kz = np.arange(0, dims[2])-Zcenter<br><br>    # construct interpolator function that does the actual computation<br>    return RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br><br><font color="orange">def </font>calculateProjection_interp_fromInterpolator(interpolator, phi, theta, psi, dims):<br>    """<br>    * calculateProjection_interp_fromInterpolator *<br><br>    Calculate a projection from precomputed interpolator object<br><br>    :param interpolator: RegularGridInterpolator object from scipy.<br>    :param phi: euler angle 1<br>    :param theta: euler angle 2<br>    :param psi: euler angle 3<br>    :param dims: dimensions of the object<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br>    """<br>    # X, Y, Z = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), 0)<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    # build coordinates of the slice we want to calculate<br>    kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(kx_slice)])<br>    rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>    rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>    rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    projection = interpolator(rotKCoords.T)<br>    projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br><br><br>    return np.real(pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(projection))))<br><br><font color="orange">def </font>generateKspaceIndices(obj):<br>    """<br>    * generateKspaceIndices *<br><br>    Maps the radial coordinate indices in the matrix obj<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br><br>    :param obj: Matrix of size to be mapped<br>    :return: 3D indices for each voxel in the volume<br>    """<br><br>    dims = np.shape(obj)<br>    <font color="orange">if </font>len(dims) < 3:<br>        dims = dims + (0,)<br><br>    <font color="orange">if </font>dims[0] % 2 == 0:<br>        ncK0 = dims[0]/2<br>        vec0 = np.arange(-ncK0, ncK0, 1)/ncK0<br>    <font color="orange">el<font color="orange">if </font></font>dims[0] == 1:<br>        vec0 = 0<br>        ncK0 = 1<br><br>    else:<br>        ncK0 = ((dims[0]+1)/2)-1<br>        vec0 = np.arange(-ncK0, ncK0+1)/ncK0<br><br><br>    <font color="orange">if </font>dims[1] % 2 == 0:<br>        ncK1 = dims[1]/2<br>        vec1 = np.arange(-ncK1, ncK1, 1)/ncK1<br>    <font color="orange">el<font color="orange">if </font></font>dims[1] == 1:<br>        vec1 = 0<br>        ncK1 = 1<br><br>    else:<br>        ncK1 = ((dims[1]+1)/2)-1<br>        vec1 = np.arange(-ncK1, ncK1+1)/ncK1<br><br><br>    <font color="orange">if </font>dims[2] % 2 == 0:<br>        ncK2 = dims[2]/2<br>        vec2 = np.arange(-ncK2, ncK2, 1)/ncK2<br>    <font color="orange">el<font color="orange">if </font></font>dims[2] == 1:<br>        vec2 = 0<br>        ncK2 = 1<br><br>    else:<br>        ncK2 = ((dims[2]+1)/2)-1<br>        vec2 = np.arange(-ncK2, ncK2+1)/ncK2<br><br>    kx, ky, kz = np.meshgrid(vec1,vec0,vec2)<br>    Kindices = np.sqrt(kx**2 + ky**2 + kz**2)<br>    return Kindices</code></body>
    </html>