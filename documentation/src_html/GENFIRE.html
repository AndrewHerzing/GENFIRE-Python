<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>../GENFIRE</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><br><font color="green">from</font> __future__ <font color="green">import</font> division<br><font color="green">import</font> numpy as np<br><font color="green">import</font> matplotlib<br>matplotlib.use("Qt4Agg")<br><br><font color="green">import</font> matplotlib.pyplot as plt<br><font color="green">import</font> scipy.fftpack as sfft<br><font color="green">import</font> os<br><font color="green">import</font> scipy.io<br><font color="green">import</font> pyfftw<br><font color="green">import</font> time<br><font color="green">import</font> GENFIRE_<font color="green">from</font>_GUI_Input<br><font color="green">import</font> misc<br><font color="green">import</font> itertools<br><font color="green">import</font> weightValues<br><font color="green">from</font> multiprocessing <font color="green">import</font> Pool<br><br><br>PI = 3.14159265359<br><br><br><font color="green">if</font> __name__ != "<font color="green">__main__</font>":<br>    <font color="green">def</font> GENFIRE_iterate(numIterations,initialObject,support,measuredK,constraintIndicators,constraintEn<font color="green">for</font>cementDelayIndicators,R_freeInd_complex,R_freeVals_complex,displayFigure):<br>        """<br>         * GENFIRE_iterate *<br><br>         Primary GENFIRE reconstruction function<br><br><br>         Author: Alan (AJ) Pryor, Jr.<br>         Jianwei (John) Miao Coherent Imaging Group<br>         University of Cali<font color="green">for</font>nia, Los Angeles<br>         Copyright 2015-2016. All rights reserved.<br><br><br>        :param numIterations: Integer number of iterations to run<br>        :param initialObject: Initial guess of 3D object<br>        :param support: Binary matrix representing where the object is allowed to exist<br>        :param measuredK: Assembled 3D Fourier grid<br>        :param constraintIndicators: Flag value <font color="green">for</font> each datapoint used to control during which iterations a given Fourier component is en<font color="green">for</font>ced<br>        :param constraintEn<font color="green">for</font>cementDelayIndicators: List of cutoff values that will be divided evenly among the iterations. All Fourier grid points with constraintIndicators greater than the current cutoff are en<font color="green">for</font>ced<br>        :param R_freeInd_complex: 3 x 1 x num_shells tuple of (x,y,z) coordinate lists <font color="green">for</font> withheld values <font color="green">for</font> Rfree calculation<br>        :param R_freeVals_complex: Complex valued component at the indices given by R_freeInd_complex<br>        :param displayFigure: Boolean flag to display figures during the reconstruction<br>        :return: outputs dictionary containing the reconstruction and error metrics<br>        """<br><br>        NUMTHREADS = 6 #number of threads to be used <font color="green">for</font> the FFTW interface<br>        bestErr = 1e30 #initialize error<br><br>        #initialize arrays <font color="green">for</font> error metrics<br>        Rfree_complex = np.ones(numIterations)*-1 #<br>        errK = np.zeros(numIterations)<br><br>        #prefetch indices <font color="green">for</font> monitoring error<br>        errInd = measuredK != 0<br><br>        #get dimensions of object<br>        dims = np.shape(support)<br>        <font color="green">if</font> R_freeInd_complex:<br>            Rfree_complex = np.zeros((np.shape(R_freeInd_complex)[2], numIterations))<br><br>        <font color="green">if</font> displayFigure.DisplayFigureON: #setup some indices <font color="green">for</font> plotting.<br>            n_half_x = int(dims[0]/2) #this assumes even-sized arrays<br>            n_half_y = int(dims[1]/2)<br>            n_half_z = int(dims[2]/2)<br><br>            half_window_x = displayFigure.reconstructionDisplayWindowSize[0]//2<br>            half_window_y = displayFigure.reconstructionDisplayWindowSize[1]//2<br>            half_window_z = displayFigure.reconstructionDisplayWindowSize[2]//2<br><br>        #setup output dict<br>        <font color="green">if</font> R_freeInd_complex:<br>            outputs = {'reconstruction':initialObject,'errK':errK,'R_free':Rfree_complex}<br>        else:<br>            outputs = {'reconstruction':initialObject,'errK':errK}<br><br>        #determine how to divide up the constraint en<font color="green">for</font>cement cutoffs among the iterations by determining<br>        #which iterations will require a recalculation of the indices to en<font color="green">for</font>ce<br>        iterationNumsToChangeCutoff = np.round(np.linspace(1, numIterations, num=np.size(constraintEn<font color="green">for</font>cementDelayIndicators)))<br>        iterationNumsToChangeCutoff, uniqueIndices = np.unique(iterationNumsToChangeCutoff, return_index=True)<br>        iterationNumsToChangeCutoff = np.append(iterationNumsToChangeCutoff,1e30) #add an arbitrarily high number to the end that is an iteration number that won't be reached<br>        constraintEn<font color="green">for</font>cementDelayIndicators = constraintEn<font color="green">for</font>cementDelayIndicators[uniqueIndices]<br>        currentCutoffNum = 0<br>        <font color="green">for</font> iterationNum in range(1, numIterations+1): #iterations are counted started <font color="green">from</font> 1<br><br>            <font color="green">if</font> iterationNum == iterationNumsToChangeCutoff[currentCutoffNum]: #update current Fourier constraint <font color="green">if</font> appropriate<br>                relevantCutoff = constraintEn<font color="green">for</font>cementDelayIndicators[currentCutoffNum]<br>                constraintInd_complex = (constraintIndicators > relevantCutoff) * measuredK != 0<br><br>                bestErr = 1e30 #reset error<br>                currentCutoffNum+=1#update constraint set number<br><br><br>            <font color="green">if</font> iterationNum%25==0:<br>                print ("iteration number: ", iterationNum)<br>            initialObject[initialObject<0] = 0 #en<font color="green">for</font>ce positivity<br>            initialObject = initialObject * support #en<font color="green">for</font>ce support<br><br>            #take FFT of current reconstruction<br>            k = pyfftw.interfaces.numpy_fft.rfftn(initialObject,overwrite_input=True,threads=NUMTHREADS)<br><br>            #compute error<br>            errK[iterationNum-1] = np.sum(abs(k[errInd]-measuredK[errInd]))/np.sum(abs(measuredK[errInd]))#monitor error<br><br>            #update best object <font color="green">if</font> a better one has been found<br>            <font color="green">if</font> errK[iterationNum-1] < bestErr:<br>                bestErr = errK[iterationNum-1]<br>                outputs['reconstruction'] = initialObject<br><br>            #calculate Rfree <font color="green">for</font> each spatial frequency shell <font color="green">if</font> necessary<br>            <font color="green">if</font> R_freeInd_complex:<br>                <font color="green">for</font> shellNum in range(0, np.shape(R_freeInd_complex)[2]):<br><br>                    tmpIndX = R_freeInd_complex[0][0][shellNum]<br>                    tmpIndY = R_freeInd_complex[1][0][shellNum]<br>                    tmpIndZ = R_freeInd_complex[2][0][shellNum]<br><br>                    tmpVals = R_freeVals_complex[shellNum]<br>                    Rfree_complex[shellNum, iterationNum-1] = np.sum(abs(k[tmpIndX, tmpIndY, tmpIndZ] - tmpVals)) / np.sum(abs(tmpVals))<br><br>            #replace Fourier components with ones <font color="green">from</font> measured data <font color="green">from</font> the current set of constraints<br>            k[constraintInd_complex] = measuredK[constraintInd_complex]<br>            initialObject = pyfftw.interfaces.numpy_fft.irfftn(k,overwrite_input=True,threads=NUMTHREADS)<br><br>            #update display<br>            <font color="green">if</font> displayFigure.DisplayFigureON:<br>                <font color="green">if</font> iterationNum % displayFigure.displayFrequency == 0:<br><br>                    plt.figure(1)<br>                    plt.subplot(233)<br>                    plt.imshow(np.squeeze(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(initialObject)[n_half_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z]))<br>                    plt.title("central YZ slice")<br><br>                    plt.subplot(232)<br>                    plt.imshow(np.squeeze(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y, n_half_z-half_window_z:n_half_z+half_window_z]))<br>                    plt.title("central XZ slice")<br><br>                    plt.subplot(231)<br>                    plt.title("central XY slice")<br>                    plt.imshow(np.squeeze(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z]))<br><br>                    plt.subplot(236)<br>                    plt.title("YZ projection")<br>                    plt.imshow(np.squeeze(np.sum(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=0)))<br><br>                    plt.subplot(235)<br>                    plt.title("XZ projection")<br>                    plt.imshow(np.squeeze(np.sum(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=1)))<br><br>                    plt.subplot(234)<br>                    plt.title("XY projection")<br>                    plt.imshow(np.squeeze(np.sum(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=2)))<br>                    plt.get_current_fig_manager().window.setGeometry(25,25,400, 400)<br>                    plt.draw()<br><br>                    plt.figure(2)<br>                    plt.get_current_fig_manager().window.setGeometry(25,450,400, 400)<br>                    plt.hold(False)<br>                    plt.plot(range(0,numIterations),errK)<br>                    plt.title("K-space Error vs Iteration Number")<br>                    plt.xlabel("Spatial Frequency (% of Nyquist)")<br>                    plt.ylabel('Reciprocal Space Error')<br>                    plt.draw()<br><br>                    <font color="green">if</font> R_freeInd_complex:<br>                        plt.figure(3)<br>                        mngr = plt.get_current_fig_manager()<br>                        mngr.window.setGeometry(450,25,400, 400)<br>                        plt.plot(range(0,numIterations),np.mean(Rfree_complex,axis=0))<br>                        plt.title("Mean R-free Value vs Iteration Number")<br>                        plt.xlabel("Iteration Num")<br>                        plt.ylabel('Mean R-free')<br>                        plt.draw()<br><br>                        plt.figure(4)<br>                        mngr = plt.get_current_fig_manager()<br>                        mngr.window.setGeometry(450,450,400, 400)<br>                        plt.hold(False)<br>                        X = np.linspace(0,1,np.shape(Rfree_complex)[0])<br>                        plt.plot(X, Rfree_complex[:,iterationNum-1])<br>                        plt.hold(False)<br>                        plt.title("Current Rfree Value vs Spatial Frequency")<br>                        plt.xlabel("Spatial Frequency (% of Nyquist)")<br>                        plt.ylabel('Rfree')<br>                        plt.draw()<br><br><br>                    plt.pause(1e-30) #<font color="green">for</font>ces display to update<br><br>        outputs['errK'] = errK<br>        <font color="green">if</font> R_freeInd_complex:<br>            outputs['R_free'] = Rfree_complex<br>        outputs['reconstruction'] = np.fft.fftsh<font color="green">if</font>t(outputs['reconstruction'])<br>        return outputs<br><br>    <font color="green">def</font> generateKspaceIndices(obj):<br>        """<br>        * generateKspaceIndices *<br><br>        Maps the radial coordinate indices in the matrix obj<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br><br>        :param obj: Matrix of size to be mapped<br>        :return: 3D indices <font color="green">for</font> each voxel in the volume<br>        """<br><br>        dims = np.shape(obj)<br>        <font color="green">if</font> len(dims) < 3:<br>            dims = dims + (0,)<br><br>        <font color="green">if</font> dims[0] % 2 == 0:<br>            ncK0 = dims[0]/2<br>            vec0 = np.arange(-ncK0, ncK0, 1)/ncK0<br>        el<font color="green">if</font> dims[0] == 1:<br>            vec0 = 0<br>            ncK0 = 1<br><br>        else:<br>            ncK0 = ((dims[0]+1)/2)-1<br>            vec0 = np.arange(-ncK0, ncK0+1)/ncK0<br><br><br>        <font color="green">if</font> dims[1] % 2 == 0:<br>            ncK1 = dims[1]/2<br>            vec1 = np.arange(-ncK1, ncK1, 1)/ncK1<br>        el<font color="green">if</font> dims[1] == 1:<br>            vec1 = 0<br>            ncK1 = 1<br><br>        else:<br>            ncK1 = ((dims[1]+1)/2)-1<br>            vec1 = np.arange(-ncK1, ncK1+1)/ncK1<br><br><br>        <font color="green">if</font> dims[2] % 2 == 0:<br>            ncK2 = dims[2]/2<br>            vec2 = np.arange(-ncK2, ncK2, 1)/ncK2<br>        el<font color="green">if</font> dims[2] == 1:<br>            vec2 = 0<br>            ncK2 = 1<br><br>        else:<br>            ncK2 = ((dims[2]+1)/2)-1<br>            vec2 = np.arange(-ncK2, ncK2+1)/ncK2<br><br>        kx, ky, kz = np.meshgrid(vec1,vec0,vec2)<br>        Kindices = np.sqrt(kx**2 + ky**2 + kz**2)<br>        return Kindices<br><br><br><br><br><br><br>    <font color="green">def</font> fillInFourierGrid(projections,angles,interpolationCutoffDistance):<br>        """<br>        * fillInFourierGrid *<br><br>        Primary function <font color="green">for</font> converting a set of 2D projection images into a 3D Fourier grid<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param projections: N x N x num_projections NumPy array containing the projections<br>        :param angles: 3 x num_projections NumPy array of Euler angles phi,theta, psi<br>        :param interpolationCutoffDistance: Radius of interpolation kernel. Only values within this radius of a grid point are considered<br>        :return: the assembled Fourier grid<br><br>        """<br>        tic = time.time()<br>        dim1 = np.shape(projections)[0]<br>        dim2 = np.shape(projections)[1]<br>        <font color="green">if</font> len(np.shape(projections))>2:<br>            numProjections = np.shape(projections)[2]<br>        else:<br>            numProjections = 1<br>        nc = np.round(dim1/2)<br>        n2 = nc<br>        measuredX = np.zeros([dim1*dim2,numProjections])<br>        measuredY = np.zeros([dim1*dim2,numProjections])<br>        measuredZ = np.zeros([dim1*dim2,numProjections])<br>        kMeasured = np.zeros([dim1,dim1,numProjections], dtype=complex)<br>        confidenceWeights = np.zeros([dim1,dim1,numProjections]) #do I need this??<br>        ky,kx = np.meshgrid(np.arange(-n2,n2,1),np.arange(-n2,n2,1))<br>        Q = np.sqrt(ky**2+kx**2)/n2<br>        kx = np.reshape(kx, [1, dim1*dim2], 'F')<br>        ky = np.reshape(ky, [1, dim1*dim2], 'F')<br>        kz = np.zeros([1, dim1*dim1])<br>        <font color="green">for</font> projNum in range(0, numProjections):<br>            phi = angles[0, projNum] * PI/180<br>            theta = angles[1, projNum] * PI/180<br>            psi = angles[2, projNum] * PI/180<br>            R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) ,np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>            [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>            [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br>            R = R.T<br><br>            Kcoordinates = np.zeros([3, dim1*dim2])<br>            Kcoordinates[0, :] = kx<br>            Kcoordinates[1, :] = ky<br>            Kcoordinates[2, :] = kz<br><br><br>            rotkCoords = np.dot(R, Kcoordinates)<br>            confidenceWeights[:, :, projNum] = np.ones_like(Q) #this implementation does not support individual projection weighting, so just set all weights to 1<br>            measuredX[:, projNum] = rotkCoords[0, :]<br>            measuredY[:, projNum] = rotkCoords[1, :]<br>            measuredZ[:, projNum] = rotkCoords[2, :]<br>            kMeasured[:, :, projNum] = np.fft.fftsh<font color="green">if</font>t(np.fft.fftn(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(projections[:, :, projNum])))<br><br>        measuredX = np.reshape(measuredX,[1, np.size(kMeasured)], 'F')<br>        measuredY = np.reshape(measuredY,[1, np.size(kMeasured)], 'F')<br>        measuredZ = np.reshape(measuredZ,[1, np.size(kMeasured)], 'F')<br>        kMeasured = np.reshape(kMeasured,[1, np.size(kMeasured)], 'F')<br>        confidenceWeights = np.reshape(confidenceWeights,[1, np.size(kMeasured)], 'F')<br>        notFlaggedIndices = kMeasured != -999<br>        measuredX = measuredX[notFlaggedIndices]<br>        measuredY = measuredY[notFlaggedIndices]<br>        measuredZ = measuredZ[notFlaggedIndices]<br>        kMeasured = kMeasured[notFlaggedIndices]<br>        confidenceWeights = confidenceWeights[notFlaggedIndices]<br><br>        masterInd = []<br>        masterVals = []<br>        masterDistances = []<br>        masterConfidenceWeights = []<br>        sh<font color="green">if</font>tMax = 0<br><br>        <font color="green">for</font> Ysh<font color="green">if</font>t in range(-sh<font color="green">if</font>tMax, sh<font color="green">if</font>tMax+1):<br>            <font color="green">for</font> Xsh<font color="green">if</font>t in range(-sh<font color="green">if</font>tMax, sh<font color="green">if</font>tMax+1):<br>                <font color="green">for</font> Zsh<font color="green">if</font>t in range(-sh<font color="green">if</font>tMax, sh<font color="green">if</font>tMax+1):<br><br>                    tmpX = np.round(measuredX) + Xsh<font color="green">if</font>t<br>                    tmpY = np.round(measuredY) + Ysh<font color="green">if</font>t<br>                    tmpZ = np.round(measuredZ) + Zsh<font color="green">if</font>t<br><br><br>                    tmpVals = kMeasured<br>                    tmpConfidenceWeights = confidenceWeights<br>                    distances = np.sqrt(abs(measuredX-tmpX)**2 + abs(measuredY-tmpY)**2 + abs(measuredZ-tmpZ)**2)<br>                    tmpX+=nc<br>                    tmpY+=nc<br>                    tmpZ+=nc<br><br>                    goodInd = (np.logical_not((tmpX > (dim1-1)) | (tmpX < 0) | (tmpY > (dim1-1)) | (tmpY < 0) | (tmpZ > (dim1-1)) | (tmpZ < 0))) & (distances <= interpolationCutoffDistance)<br><br>                    masterInd=np.append(masterInd, np.ravel_multi_index((tmpX[goodInd].astype(np.int64), tmpY[goodInd].astype(np.int64), tmpZ[goodInd].astype(np.int64)),[dim1, dim1, dim1], order='F'))<br>                    masterVals=np.append(masterVals, tmpVals[goodInd])<br>                    masterDistances=np.append(masterDistances, distances[goodInd])<br>                    masterConfidenceWeights=np.append(masterConfidenceWeights, tmpConfidenceWeights[goodInd])<br><br><br>                    t = 0<br><br>        masterInd = np.array(masterInd).astype(np.int64)<br>        masterVals = np.array(masterVals)<br>        masterDistances = np.array(masterDistances)<br>        masterConfidenceWeights = np.array(masterConfidenceWeights)<br><br><br><br>        sortIndices = np.argsort(masterInd)<br>        masterInd = masterInd[sortIndices]<br>        masterVals = masterVals[sortIndices]<br>        masterDistances = masterDistances[sortIndices]<br>        masterConfidenceWeights = masterConfidenceWeights[sortIndices]<br><br><br>        halfwayCutoff = ((dim1+1)**3)//2+1<br><br><br>        masterVals = masterVals[masterInd <= halfwayCutoff]<br>        masterDistances = masterDistances[masterInd <= halfwayCutoff]<br>        masterConfidenceWeights = masterConfidenceWeights[masterInd <= halfwayCutoff]<br>        masterInd = masterInd[masterInd <= halfwayCutoff]<br><br><br>        uniqueVals, uniqueInd = np.unique(masterInd, return_index=True)<br><br>        uniqueInd = np.append(uniqueInd, 0)<br><br>        d<font color="green">if</font>fVec = np.d<font color="green">if</font>f(uniqueInd)<br>        singleInd = d<font color="green">if</font>fVec == 1<br>        multiInd = np.where(d<font color="green">if</font>fVec != 1)<br>        measuredK = np.zeros([dim1**3], dtype=complex)<br><br>        measuredK[uniqueVals[singleInd]] = masterVals[uniqueInd[0:-1][singleInd]]<br><br>        vals = weightValues.weightValue(np.array(multiInd[0][:],dtype=int), uniqueInd, masterDistances, masterVals)<br><br>        measuredK[uniqueVals[multiInd[0][:]]] = vals<br>        measuredK = np.reshape(measuredK,[dim1,dim1,dim1],order='F')<br><br>        # print ("time3 " , time.time()-tic3)<br>        measuredK[np.isnan(measuredK)] = 0<br>        measuredK = misc.hermitianSymmetrize(measuredK)<br><br>        print ("GENFIRE: Fourier grid assembled in %d seconds" % (time.time()-tic))<br>        return measuredK<br><br><br><br><br>    <font color="green">def</font> loadProjections(filename):<br>        """<br>        * loadProjections *<br><br>        Wrapper function <font color="green">for</font> loading in projections of arbitrary (supported) extension<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: Filename of images to load<br>        :return: NumPy array containing projections<br>        """<br>        <font color="green">import</font> GENFIRE_io<br>        filename, file_extension = os.path.splitext(filename)<br>        <font color="green">if</font> file_extension == ".mat":<br>            print ("GENFIRE: reading projections <font color="green">from</font> MATLAB file.\n")<br>            return GENFIRE_io.readMAT(filename + file_extension)<br>        el<font color="green">if</font> file_extension == ".t<font color="green">if</font>":<br>            print ("GENFIRE: reading projections <font color="green">from</font> .t<font color="green">if</font> file.\n")<br>            return GENFIRE_io.readTIFF(filename + file_extension)<br>        el<font color="green">if</font> file_extension == ".mrc":<br>            print ("GENFIRE: reading projections <font color="green">from</font> .mrc file.\n")<br>            return GENFIRE_io.readMRC(filename + file_extension)<br>        else:<br>            raise Exception('GENFIRE: File <font color="green">for</font>mat %s not supported.', file_extension)<br><br>    <font color="green">def</font> readMAT(filename):<br>        """<br>        * readMAT *<br><br>        Read projections <font color="green">from</font> a .mat file<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: MATLAB file (.mat) containing projections<br>        :return: NumPy array containing projections<br>        """<br><br>        try: #try to open the projections as a stack<br>            projections = scipy.io.loadmat(filename)<br>            projections = np.array(projections[projections.keys()[0]])<br>        except: ## -- figure out where error is thrown<br>             #check <font color="green">if</font> the projections are in individual files<br>            flag = True<br>            filename_base, file_extension = os.path.splitext(filename)<br>            projectionCount = 1<br>            <font color="green">while</font> flag: #first count the number of projections so the array can be initialized<br>                projectionCount = projectionCount<br>                nextFile = filename_base + str(projectionCount) + file_extension<br>                <font color="green">if</font> os.path.isfile(nextFile):<br>                    projectionCount += 1<br>                else:<br>                    flag = False<br><br><br>            ## open first projection to get dimensions<br>            pj = scipy.io.loadmat(filename_base + str(1) + file_extension)<br>            pj = pj[projections.keys()[0]]<br>            dims = np.shape(pj)<br>            #initialize projection array<br>            projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>            #now actually load in the t<font color="green">if</font>f images<br>            <font color="green">for</font> projNum in range(projectionCount):<br>                nextFile = filename_base + str(projNum) + file_extension<br>                pj = scipy.io.loadmat(filename_base + str(projNum) + file_extension)<br>                pj = pj[pj.keys()[0]]<br>                projections[:, :, projNum] = np.array(pj)<br><br>        return projections<br><br><br>    <font color="green">def</font> readTIFF(filename):<br>        """<br>        * readTIFF *<br><br>        Read (possibly multiple) TIFF images into a NumPy array<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: Name of TIFF file or TIFF file basename to read. If the filename is a base then<br>        #       the images must begin with the string contained in filename followed by consecutive integers with<br>        #       no zero padding, i.e. foo1.t<font color="green">if</font>f, foo2.t<font color="green">if</font>f,..., foo275.t<font color="green">if</font>f<br>        :return: NumPy array containing projections<br>        """<br>        <font color="green">import</font> functools<br>        <font color="green">from</font> PIL <font color="green">import</font> Image<br>        <font color="green">import</font> os<br>        try:<br>            projections = np.array(Image.open(filename))<br>        except:<br>            flag = True<br>            filename_base, file_extension = os.path.splitext(filename)<br>            projectionCount = 1<br>            <font color="green">while</font> flag: #first count the number of projections so the array can be initialized<br>                projectionCount = projectionCount<br>                nextFile = filename_base + str(projectionCount) + file_extension<br>                <font color="green">if</font> os.path.isfile(nextFile):<br>                    projectionCount += 1<br>                else:<br>                    flag = False<br><br>            ## open first projection to get dimensions<br>            dims = np.shape(Image.open(filename_base + str(1) + file_extension))<br><br>            #initialize projection array<br>            projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>            pool = Pool(4)<br>            func = functools.partial(readInT<font color="green">if</font>fProjection, filename_base)<br>            pj = pool.map(func, range(projectionCount))<br>            <font color="green">for</font> j  in range(projectionCount):<br>                projections[:, :, j] = pj[j]<br>            return projections<br><br>    <font color="green">def</font> readInT<font color="green">if</font>fProjection(filename_base, fileNumber):<br>        """<br>        * readInT<font color="green">if</font>fProjection *<br><br>        Reads and returns a single TIFF image as a NumPy array<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename_base: Base filename of TIFF<br>        :param fileNumber: Image number<br>        :return: Image in a 2D NumPy array<br>        """<br>        <font color="green">from</font> PIL <font color="green">import</font> Image<br>        nextFile = filename_base + str(fileNumber) + '.t<font color="green">if</font>'<br>        return np.array(Image.open(nextFile))<br><br>    <font color="green">def</font> readMRC(filename, dtype=float,order="C"):<br>        """<br>        * readMRC *<br><br>        Read in a volume in .mrc file <font color="green">for</font>mat. See http://bio3d.colorado.edu/imod/doc/mrc_<font color="green">for</font>mat.txt<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: Filename of .mrc<br>        :return: NumPy array containing the .mrc data<br>        """<br>        <font color="green">import</font> struct<br>        headerIntNumber = 56<br>        sizeof_int = 4<br>        headerCharNumber = 800<br>        sizeof_char = 1<br>        with open(filename,'rb') as fid:<br>            int_header = struct.unpack('=' + 'i'*headerIntNumber, fid.read(headerIntNumber * sizeof_int))<br>            char_header = struct.unpack('=' + 'c'*headerCharNumber, fid.read(headerCharNumber * sizeof_char))<br>            dimx, dimy, dimz, data_flag= int_header[:4]<br>            print "reading, ", dimx,dimy,dimz<br>            <font color="green">if</font> (data_flag == 0):<br>                datatype='u1'<br>            el<font color="green">if</font> (data_flag ==1):<br>                datatype='i1'<br>            el<font color="green">if</font> (data_flag ==2):<br>                datatype='f4'<br>            el<font color="green">if</font> (data_flag ==3):<br>                datatype='c'<br>            el<font color="green">if</font> (data_flag ==4):<br>                datatype='f4'<br>            el<font color="green">if</font> (data_flag ==6):<br>                datatype='u2'<br>            else:<br>                raise ValueError("No supported datatype found!\n")<br>            print dimx,dimy,dimz<br>            print datatype<br>            return np.<font color="green">from</font>file(file=fid, dtype=datatype,count=dimx*dimy*dimz).reshape((dimx,dimy,dimz),order=order).astype(dtype)<br><br>    <font color="green">def</font> writeMRC(filename, arr, datatype='f4'):<br>        """<br>        * writeMRC *<br><br>        Write a volume to .mrc file <font color="green">for</font>mat. See http://bio3d.colorado.edu/imod/doc/mrc_<font color="green">for</font>mat.txt<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved<br><br>        :param filename: Filename of .mrc file to write<br>        :param arr: NumPy volume of data to write<br>        :param dtype: Type of data to write<br>        """<br>        dimx, dimy, dimz = np.shape(arr)<br>        <font color="green">if</font> datatype != arr.dtype:<br>            arr = arr.astype(datatype)<br>        int_header = np.zeros(56,dtype='int32')<br><br>        <font color="green">if</font> (datatype == 'u1'):<br>            data_flag = 0<br>        el<font color="green">if</font> (datatype =='i1'):<br>            data_flag = 1<br>        el<font color="green">if</font> (datatype =='f4'):<br>            data_flag = 2<br>        el<font color="green">if</font> (datatype =='c'):<br>            data_flag = 3<br>        el<font color="green">if</font> (datatype =='f4'):<br>            data_flag = 4<br>        el<font color="green">if</font> (datatype =='u2'):<br>            data_flag = 6<br>        else:<br>            raise ValueError("No supported datatype found!\n")<br><br>        int_header[:4] = (dimx,dimy,dimz,data_flag)<br>        char_header = str(' '*800)<br>        with open(filename,'wb') as fid:<br>            fid.write(int_header.tobytes())<br>            fid.write(char_header)<br>            fid.write(arr.tobytes())<br><br>    <font color="green">def</font> saveResults(reconstruction_outputs, filename):<br>        """<br>        * saveResults *<br><br>        Helper function to save results of GENFIRE reconstruction<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved<br><br>        :param reconstruction_outputs: dictionary containing reconstruction, reciprocal error (errK), and possible R_free<br>        :param filename: Output filename<br>        """<br>        <font color="green">import</font> os<br>        fn, ext = os.path.splitext(filename)<br>        writeMRC(filename, reconstruction_outputs['reconstruction'])<br>        np.savetxt(fn+'_errK.txt',reconstruction_outputs['errK'])<br>        <font color="green">if</font> 'R_free' in reconstruction_outputs.keys():<br>            np.savetxt(fn+'_Rfree.txt',reconstruction_outputs['R_free'])<br><br><br>    <font color="green">class</font> DisplayFigure:<br>        """<br>        * DisplayFigure *<br><br>        Helper <font color="green">class</font> <font color="green">for</font> displaying figures during reconstruction process<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br>        """<br>        <font color="green">def</font> __init__(<font color="green">self</font>):<br>            <font color="green">self</font>.DisplayFigureON = False<br>            <font color="green">self</font>.DisplayErrorFigureON = False<br>            <font color="green">self</font>.displayFrequency = 5<br>            <font color="green">self</font>.reconstructionDisplayWindowSize = 0<br><br>    <font color="green">def</font> loadAngles(filename):<br>        """<br>        * loadAngles *<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename:<br>        :return:<br>        """<br>        <font color="green">import</font> os<br>        base,ext = os.path.splitext(filename)<br>        ext = ext.lower()<br>        <font color="green">if</font> ext == ".txt":<br>            return np.loadtxt(filename,dtype=float)<br>        el<font color="green">if</font> ext== ".npy":<br>            return np.load(filename)<br>        el<font color="green">if</font> ext==".mat":<br>            <font color="green">import</font> scipy.io as io<br>            data = io.loadmat(filename)<br>            <font color="green">if</font> "angles" not in data.keys():<br>                raise LookupError("No variable called 'angles' found in \"{}\"!".<font color="green">for</font>mat(filename))<br>            return np.array(data['angles'],dtype=float)<br>        else:<br>            raise IOError("Unsupported file extension \"{}\" <font color="green">for</font> Euler angles".<font color="green">for</font>mat(ext))<br><br>    <font color="green">def</font> loadInitialObject(filename):<br>        """<br>        * loadInitialObject *<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of Cali<font color="green">for</font>nia, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename:<br>        :return:<br>        """<br>        <font color="green">import</font> os<br>        base,ext = os.path.splitext(filename)<br>        ext = ext.lower()<br>        <font color="green">if</font> ext == ".npy":<br>            return np.load(filename)<br>        el<font color="green">if</font> ext==".mat":<br>            <font color="green">import</font> scipy.io as io<br>            data = io.loadmat(filename)<br>            <font color="green">if</font> "initial_object" not in data.keys():<br>                raise LookupError("No variable called 'initial_object' found in \"{}\"!".<font color="green">for</font>mat(filename))<br>            return np.array(data['initial_object'],dtype=float)<br>        el<font color="green">if</font> ext==".mrc":<br>            raise NotImplementedError("mrc file <font color="green">for</font>mat not yet supported")<br>        else:<br>            raise IOError("Unsupported file extension \"{}\" <font color="green">for</font> initial object".<font color="green">for</font>mat(ext))<br><br><br><font color="green">class</font> ReconstructionParameters():<br>    _supportedFiletypes = ['.t<font color="green">if</font>', '.mrc', '.mat']<br>    _supportedAngleFiletypes = ['.txt', '.mat']<br>    <font color="green">def</font> __init__(<font color="green">self</font>):<br>        <font color="green">self</font>.projectionFilename = ""<br>        <font color="green">self</font>.angleFilename = ""<br>        <font color="green">self</font>.supportFilename = ""<br>        <font color="green">self</font>.resolutionExtensionSuppressionState = 1 #1 <font color="green">for</font> resolution extension/suppression, 2 <font color="green">for</font> off, 3 <font color="green">for</font> just extension<br>        <font color="green">self</font>.numIterations = 50<br>        <font color="green">self</font>.displayFigure = DisplayFigure()<br>        <font color="green">self</font>.oversamplingRatio = 3<br>        <font color="green">self</font>.interpolationCutoffDistance = 0.7<br>        <font color="green">self</font>.isInitialObjectDefined = False<br>        <font color="green">self</font>.resultsFilename = os.path.join(os.getcwd(), 'results.mrc')<br>        <font color="green">self</font>.useDefaultSupport = True<br>        <font color="green">self</font>.calculateRfree = False<br><br>    <font color="green">def</font> checkParameters(<font color="green">self</font>): #ver<font color="green">if</font>y file extensions are supported<br>        parametersAreGood = 1<br><br>        projection_extension = os.path.splitext(<font color="green">self</font>.projectionFilename)<br>        <font color="green">if</font> projection_extension[1] not in ReconstructionParameters._supportedFiletypes:<br>            parametersAreGood = 0<br><br>        angle_extension = os.path.splitext(<font color="green">self</font>.angleFilename)<br>        <font color="green">if</font> angle_extension[1] not in ReconstructionParameters._supportedAngleFiletypes:<br>            parametersAreGood = 0<br><br>        <font color="green">if</font> <font color="green">self</font>.supportFilename != "": #empty support filename is okay, as this will trigger generation of a <font color="green">def</font>ault support<br>            support_extension = os.path.splitext(<font color="green">self</font>.supportFilename)<br>            <font color="green">if</font> support_extension[1] not in ReconstructionParameters._supportedFiletypes:<br>                parametersAreGood = 0<br><br>        <font color="green">if</font> not <font color="green">self</font>.getResultsFilename():<br>            parametersAreGood = 0<br>        return parametersAreGood<br><br>    # Define setters/getters<br>    <font color="green">def</font> setProjectionFilename(<font color="green">self</font>, projectionFilename):<br>        <font color="green">if</font> projectionFilename:<br>            <font color="green">self</font>.projectionFilename = os.path.join(os.getcwd(), unicode(projectionFilename.toUtf8(), encoding='UTF-8'))<br><br>    <font color="green">def</font> getProjectionFilename(<font color="green">self</font>):<br>        return <font color="green">self</font>.projectionFilename<br><br>    <font color="green">def</font> setAngleFilename(<font color="green">self</font>, angleFilename):<br>        <font color="green">if</font> angleFilename:<br>            <font color="green">self</font>.angleFilename = os.path.join(os.getcwd(), unicode(angleFilename.toUtf8(), encoding='UTF-8'))<br><br>    <font color="green">def</font> getAngleFilename(<font color="green">self</font>):<br>        return <font color="green">self</font>.angleFilename<br><br>    <font color="green">def</font> setSupportFilename(<font color="green">self</font>, supportFilename):<br>        <font color="green">if</font> supportFilename:<br>            <font color="green">self</font>.supportFilename = os.path.join(os.getcwd(), unicode(supportFilename.toUtf8(), encoding='UTF-8'))<br><br>    <font color="green">def</font> getSupportFilename(<font color="green">self</font>):<br>        return <font color="green">self</font>.supportFilename<br><br>    <font color="green">def</font> setResultsFilename(<font color="green">self</font>, resultsFilename):<br>        <font color="green">if</font> resultsFilename:<br>            <font color="green">self</font>.resultsFilename = os.path.join(os.getcwd(), unicode(resultsFilename.toUtf8(), encoding='UTF-8'))<br><br>    <font color="green">def</font> getResultsFilename(<font color="green">self</font>):<br>        return <font color="green">self</font>.resultsFilename<br><br><br>    <font color="green">def</font> setInitialObjectFilename(<font color="green">self</font>, initialObjectFilename):<br>        <font color="green">self</font>._initialObjectFilename = os.path.join(os.getcwd(),unicode(initialObjectFilename.toUtf8(), encoding='UTF-8'))<br>        <font color="green">self</font>.isInitialObjectDefined = True<br><br>    <font color="green">def</font> getInitialObjectFilename(<font color="green">self</font>):<br>        <font color="green">if</font> <font color="green">self</font>.CheckIfInitialObjectIsDefined():<br>            return <font color="green">self</font>._initialObjectFilename<br>        else:<br>            pass<br><br>    <font color="green">def</font> CheckIfInitialObjectIsDefined(<font color="green">self</font>):<br>        return <font color="green">self</font>.isInitialObjectDefined<br><br>    <font color="green">def</font> setResolutionExtensionSuppressionState(<font color="green">self</font>, state):<br>        <font color="green">self</font>.resolutionExtensionSuppressionState = state<br><br>    <font color="green">def</font> getResolutionExtensionSuppressionState(<font color="green">self</font>):<br>        return <font color="green">self</font>.resolutionExtensionSuppressionState<br><br>    <font color="green">def</font> setNumberOfIterations(<font color="green">self</font>,numIterations):<br>        numIterations = numIterations.toInt()<br>        <font color="green">if</font> numIterations[1]:<br>            numIterations = numIterations[0]<br>            <font color="green">if</font> numIterations > 0:<br>                <font color="green">self</font>.numIterations = numIterations<br><br>    <font color="green">def</font> getNumberOfIterations(<font color="green">self</font>):<br>        return <font color="green">self</font>.numIterations<br><br>    <font color="green">def</font> toggleDisplayFigure(<font color="green">self</font>): # whether or not to display figure during reconstruction<br>        <font color="green">if</font> <font color="green">self</font>.displayFigure.DisplayFigureON:<br>            <font color="green">self</font>.displayFigure.DisplayFigureON = False<br>        else:<br>            <font color="green">self</font>.displayFigure.DisplayFigureON = True<br><br>        <font color="green">if</font> <font color="green">self</font>.displayFigure.DisplayErrorFigureON:<br>            <font color="green">self</font>.displayFigure.DisplayErrorFigureON = False<br>        else:<br>            <font color="green">self</font>.displayFigure.DisplayErrorFigureON = True<br><br>    <font color="green">def</font> getDisplayFigure(<font color="green">self</font>):<br>        return <font color="green">self</font>.displayFigure<br><br>    <font color="green">def</font> setOversamplingRatio(<font color="green">self</font>, oversamplingRatio):<br>        <font color="green">self</font>.oversamplingRatio = oversamplingRatio.toInt()[0]<br><br>    <font color="green">def</font> getOversamplingRatio(<font color="green">self</font>):<br>        return <font color="green">self</font>.oversamplingRatio<br><br>    <font color="green">def</font> setInterpolationCutoffDistance(<font color="green">self</font>, interpolationCutoffDistance):<br>        <font color="green">self</font>.interpolationCutoffDistance = interpolationCutoffDistance.toFloat()[0]<br><br>    <font color="green">def</font> getInterpolationCutoffDistance(<font color="green">self</font>):<br>        return <font color="green">self</font>.interpolationCutoffDistance</code></body>
    </html>