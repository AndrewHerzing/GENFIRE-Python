<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>../GENFIRE_from_GUI_Input</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><font color="green">from</font> __future__ <font color="green">import</font> division<br><font color="green">import</font> numpy as np<br><font color="green">import</font> scipy.io as io<br><font color="green">import</font> matplotlib.pyplot as plt<br><font color="green">import</font> time<br><font color="green">import</font> GENFIRE<br><br><font color="green">def</font> GENFIRE_<font color="green">from</font>_GUI_Input(filename_projections,filename_angles,filename_support):<br><br><br>    <font color="green">import</font> cProfile<br><br><br>    tic = time.clock()<br>    #######################################################################################################################<br>    ############################################### User Parameters  #####################g#################################<br>    #######################################################################################################################<br>    # filename_projections = 'projections.mat'  #filename of projections, which should be size NxNxN_projections where N_projections is the number of projections<br>    # filename_angles = 'angles.mat'  #angles can be either a 1xN_projections array containing a single tilt series, or 3xN_projections array containing 3 Euler angles <font color="green">for</font> each projections in the <font color="green">for</font>m [phi;theta;psi]<br>    # filename_support = 'support60.mat'  #NxNxN binary array spec<font color="green">if</font>ying a region of 1's in which the reconstruction can exist<br>    # filename_initialObject = ''  #initial object to use in reconstruction; comment this line out <font color="green">if</font> you have no initial guess and want to start with all zeros<br>    filename_results = 'GENFIRE_rec_python.mat'  #filename to save results<br><br>    numIterations = 50  #number of iterations to run in iterative reconstruction<br>    oversamplingRatio = 3  #input projections will be padded internally to match this oversampling ratio. If you prepad your projections, set this to 1<br>    interpolationCutoffDistance = 0.7  #radius of spherical interpolation kernel (in pixels) within which to include measured datapoints<br>    #######################################################################################################################<br><br><br>    print(filename_projections)<br>    print(type(filename_projections))<br><br>    ### begin reconstruction ###<br>    projections = io.loadmat(filename_projections);projections = projections[projections.keys()[0]]<br>    angles = io.loadmat(filename_angles);angles = angles['angles']<br>    support = io.loadmat(filename_support); support = support[support.keys()[0]]<br><br>    dims = np.shape(projections)<br>    paddedDim = dims[0] * oversamplingRatio<br>    padding = int((paddedDim-dims[0])/2)<br>    # padding = padding.astype(int)<br>    support = np.pad(support,((padding,padding),(padding,padding),(padding,padding)),'constant')<br>    projections = np.pad(projections,((padding,padding),(padding,padding),(0,0)),'constant')<br>    # print np.shape(projections)<br><br>    #load initial object, or initialize it to zeros <font color="green">if</font> none was given<br>    try:<br>        initialObject = io.loadmat(filename_initialObject); initialObject = initialObject[initialObject.keys()[0]]<br>        initialObject = np.pad(initialObject,((padding,padding),(padding,padding),(padding,padding)),'constant')<br>    except NameError:<br>        initialObject = np.zeros_like(support)<br>    print(type(angles))<br>    <font color="green">if</font> np.shape(angles)[0] > 3:<br>        print ("angles dimension wrong")<br>        ##raise error about angles<br>    <font color="green">if</font> np.shape(angles)[0] == 1:<br>        tmp = np.zeros([3, np.shape(angles)[1]])<br>        tmp[1, :] = angles<br>        angles = tmp<br>        del tmp<br><br>    ticGridding = time.time()<br>    measuredK = GENFIRE.fillInFourierGrid(projections, angles, interpolationCutoffDistance)<br>    print ("Gridding Time: ",time.time()-ticGridding)<br><br>    # mk = {'mk':measuredK}<br>    # io.savemat('mk2.mat', mk)<br><br>    K_indices = GENFIRE.generateKspaceIndices(support)<br>    Q_magnitudes = np.zeros_like(K_indices)<br>    Q_magnitudes[measuredK != 0] = 1-K_indices[measuredK != 0]<br><br>    # Q_magnitudes = {'resolutionFlags':Q_magnitudes}<br>    # io.savemat('resolutionFlags.mat',Q_magnitudes)<br><br>    # constraintEn<font color="green">for</font>cementDelayFlags = np.concatenate((np.arange(0.95, -.25, -0.1), np.arange(-0.25, .95, .1)), axis=0)<br>    constraintEn<font color="green">for</font>cementDelayFlags = np.array([-5, -5, -5, -5])<br>    R_freeInd_complex = []<br>    R_freeVals_complex = []<br>    # reconstructionOutputs = GENFIRE.GENFIRE_iterate(numIterations,initialObject,support,measuredK,resolutionFlags,constraintEn<font color="green">for</font>cementDelayFlags,R_freeInd_complex,R_freeVals_complex);<br>    ticRecon = time.time()<br>    # cProfile.run('reconstructionOutputs = GENFIRE.GENFIRE_iterate(numIterations,np.fft.fftsh<font color="green">if</font>t(initialObject),np.fft.fftsh<font color="green">if</font>t(support),np.fft.fftsh<font color="green">if</font>t(measuredK)[:, :, 0:(np.shape(measuredK)[-1]//2+1)],np.fft.fftsh<font color="green">if</font>t(Q_magnitudes)[:, :, 0:(np.shape(measuredK)[-1]//2+1)],constraintEn<font color="green">for</font>cementDelayFlags,R_freeInd_complex,R_freeVals_complex)')<br>    reconstructionOutputs = GENFIRE.GENFIRE_iterate(numIterations,np.fft.fftsh<font color="green">if</font>t(initialObject),np.fft.fftsh<font color="green">if</font>t(support),np.fft.fftsh<font color="green">if</font>t(measuredK)[:, :, 0:(np.shape(measuredK)[-1]//2+1)],np.fft.fftsh<font color="green">if</font>t(Q_magnitudes)[:, :, 0:(np.shape(measuredK)[-1]//2+1)],constraintEn<font color="green">for</font>cementDelayFlags,R_freeInd_complex,R_freeVals_complex)<br>    print ("Reconstruction Time: ",time.time()-ticRecon)<br>    print ('GENFIRE: Reconstruction finished. Total computation time = ', time.clock()-tic)<br>    io.savemat(filename_results,reconstructionOutputs)<br><br><br>    # plt.figure(5)<br>    # plt.imshow(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(reconstructionOutputs['reconstruction'])[:, :, 90])<br>    # #plt.imshow(abs((constraintConfidenceWeights)[:, :, 0]))<br>    # plt.draw()<br>    # plt.pause(.1)<br><font color="green">if</font> __name__ == "<font color="green">__main__</font>":<br>    print("why am i here?")<br>    filename_projections = 'projections.mat'  #filename of projections, which should be size NxNxN_projections where N_projections is the number of projections<br>    filename_angles = 'angles.mat'  #angles can be either a 1xN_projections array containing a single tilt series, or 3xN_projections array containing 3 Euler angles <font color="green">for</font> each projections in the <font color="green">for</font>m [phi;theta;psi]<br>    filename_support = 'support60.mat'  #NxNxN binary array spec<font color="green">if</font>ying a region of 1's in which the reconstruction can exist<br><br>    GENFIRE_<font color="green">from</font>_GUI_Input(filename_projections,filename_angles,filename_support)</code></body>
    </html>