<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>..//GENFIRE/reconstruct</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><font color="orange">from </font>__future__ <font color="orange">import </font>division<br><font color="orange">import </font>numpy as np<br><font color="orange">import </font>matplotlib<br>matplotlib.use("Qt4Agg")<br><font color="orange">import </font>matplotlib.pyplot as plt<br><font color="orange">import </font>os<br><font color="orange">import </font>scipy.io<br><font color="orange">import </font>pyfftw<br><font color="orange">import </font>time<br><font color="orange">import </font><b><font color="orange">GENFIRE</font></b>.utility<br><font color="orange">import </font>weightValues<br><font color="orange">from </font>multiprocessing <font color="orange">import </font>Pool<br><br><br>PI = np.pi<br><font color="orange">if </font>__name__ != "__main__":<br>    <font color="orange">def </font>reconstruct(numIterations, initialObject, support, measuredK, constraintIndicators, constraintEnforcementDelayIndicators, R_freeInd_complex, R_freeVals_complex, displayFigure):<br>        """<br>         * reconstruct *<br><br>         Primary GENFIRE reconstruction function<br><br><br>         Author: Alan (AJ) Pryor, Jr.<br>         Jianwei (John) Miao Coherent Imaging Group<br>         University of California, Los Angeles<br>         Copyright 2015-2016. All rights reserved.<br><br><br>        :param numIterations: Integer number of iterations to run<br>        :param initialObject: Initial guess of 3D object<br>        :param support: Binary matrix representing where the object is allowed to exist<br>        :param measuredK: Assembled 3D Fourier grid<br>        :param constraintIndicators: Flag value for each datapoint used to control during which iterations a given Fourier component is enforced<br>        :param constraintEnforcementDelayIndicators: List of cutoff values that will be divided evenly among the iterations. All Fourier grid points with constraintIndicators greater than the current cutoff are enforced<br>        :param R_freeInd_complex: 3 x 1 x num_shells tuple of (x,y,z) coordinate lists for withheld values for Rfree calculation<br>        :param R_freeVals_complex: Complex valued component at the indices given by R_freeInd_complex<br>        :param displayFigure: Boolean flag to display figures during the reconstruction<br>        :return: outputs dictionary containing the reconstruction and error metrics<br>        """<br><br>        NUMTHREADS = 6 #number of threads to be used for the FFTW interface<br>        bestErr = 1e30 #initialize error<br><br>        #initialize arrays for error metrics<br>        Rfree_complex = np.ones(numIterations)*-1 #<br>        errK = np.zeros(numIterations)<br><br>        #prefetch indices for monitoring error<br>        errInd = measuredK != 0<br><br>        #get dimensions of object<br>        dims = np.shape(support)<br>        if R_freeInd_complex:<br>            Rfree_complex = np.zeros((np.shape(R_freeInd_complex)[2], numIterations))<br><br>        if displayFigure.DisplayFigureON: #setup some indices for plotting.<br>            n_half_x = int(dims[0]/2) #this assumes even-sized arrays<br>            n_half_y = int(dims[1]/2)<br>            n_half_z = int(dims[2]/2)<br><br>            half_window_x = displayFigure.reconstructionDisplayWindowSize[0]//2<br>            half_window_y = displayFigure.reconstructionDisplayWindowSize[1]//2<br>            half_window_z = displayFigure.reconstructionDisplayWindowSize[2]//2<br><br>        #setup output dict<br>        if R_freeInd_complex:<br>            outputs = {'reconstruction':initialObject,'errK':errK,'R_free':Rfree_complex}<br>        else:<br>            outputs = {'reconstruction':initialObject,'errK':errK}<br><br>        #determine how to divide up the constraint enforcement cutoffs among the iterations by determining<br>        #which iterations will require a recalculation of the indices to enforce<br>        iterationNumsToChangeCutoff = np.round(np.linspace(1, numIterations, num=np.size(constraintEnforcementDelayIndicators)))<br>        iterationNumsToChangeCutoff, uniqueIndices = np.unique(iterationNumsToChangeCutoff, return_index=True)<br>        iterationNumsToChangeCutoff = np.append(iterationNumsToChangeCutoff,1e30) #add an arbitrarily high number to the end that is an iteration number that won't be reached<br>        constraintEnforcementDelayIndicators = constraintEnforcementDelayIndicators[uniqueIndices]<br>        currentCutoffNum = 0<br>        for iterationNum in range(1, numIterations+1): #iterations are counted started from 1<br><br>            if iterationNum == iterationNumsToChangeCutoff[currentCutoffNum]: #update current Fourier constraint if appropriate<br>                relevantCutoff = constraintEnforcementDelayIndicators[currentCutoffNum]<br>                constraintInd_complex = (constraintIndicators > relevantCutoff) * measuredK != 0<br><br>                bestErr = 1e30 #reset error<br>                currentCutoffNum+=1#update constraint set number<br><br><br>            if iterationNum%25==0:<br>                print ("iteration number: ", iterationNum)<br>            initialObject[initialObject<0] = 0 #enforce positivity<br>            initialObject = initialObject * support #enforce support<br><br>            #take FFT of current reconstruction<br>            k = pyfftw.interfaces.numpy_fft.rfftn(initialObject,overwrite_input=True,threads=NUMTHREADS)<br><br>            #compute error<br>            errK[iterationNum-1] = np.sum(abs(k[errInd]-measuredK[errInd]))/np.sum(abs(measuredK[errInd]))#monitor error<br><br>            #update best object if a better one has been found<br>            if errK[iterationNum-1] < bestErr:<br>                bestErr = errK[iterationNum-1]<br>                outputs['reconstruction'] = initialObject<br><br>            #calculate Rfree for each spatial frequency shell if necessary<br>            if R_freeInd_complex:<br>                for shellNum in range(0, np.shape(R_freeInd_complex)[2]):<br><br>                    tmpIndX = R_freeInd_complex[0][0][shellNum]<br>                    tmpIndY = R_freeInd_complex[1][0][shellNum]<br>                    tmpIndZ = R_freeInd_complex[2][0][shellNum]<br><br>                    tmpVals = R_freeVals_complex[shellNum]<br>                    Rfree_complex[shellNum, iterationNum-1] = np.sum(abs(k[tmpIndX, tmpIndY, tmpIndZ] - tmpVals)) / np.sum(abs(tmpVals))<br><br>            #replace Fourier components with ones from measured data from the current set of constraints<br>            k[constraintInd_complex] = measuredK[constraintInd_complex]<br>            initialObject = pyfftw.interfaces.numpy_fft.irfftn(k,overwrite_input=True,threads=NUMTHREADS)<br><br>            #update display<br>            if displayFigure.DisplayFigureON:<br>                if iterationNum % displayFigure.displayFrequency == 0:<br><br>                    plt.figure(1000)<br>                    plt.subplot(233)<br>                    plt.imshow(np.squeeze(np.fft.ifftshift(initialObject)[n_half_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z]))<br>                    plt.title("central YZ slice")<br><br>                    plt.subplot(232)<br>                    plt.imshow(np.squeeze(np.fft.ifftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y, n_half_z-half_window_z:n_half_z+half_window_z]))<br>                    plt.title("central XZ slice")<br><br>                    plt.subplot(231)<br>                    plt.title("central XY slice")<br>                    plt.imshow(np.squeeze(np.fft.ifftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z]))<br><br>                    plt.subplot(236)<br>                    plt.title("YZ projection")<br>                    plt.imshow(np.squeeze(np.sum(np.fft.ifftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=0)))<br><br>                    plt.subplot(235)<br>                    plt.title("XZ projection")<br>                    plt.imshow(np.squeeze(np.sum(np.fft.ifftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=1)))<br><br>                    plt.subplot(234)<br>                    plt.title("XY projection")<br>                    plt.imshow(np.squeeze(np.sum(np.fft.ifftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=2)))<br>                    plt.get_current_fig_manager().window.setGeometry(25,25,400, 400)<br>                    plt.draw()<br><br>                    plt.figure(2)<br>                    plt.get_current_fig_manager().window.setGeometry(25,450,400, 400)<br>                    plt.hold(False)<br>                    plt.plot(range(0,numIterations),errK)<br>                    plt.title("K-space Error vs Iteration Number")<br>                    plt.xlabel("Spatial Frequency (% of Nyquist)")<br>                    plt.ylabel('Reciprocal Space Error')<br>                    plt.draw()<br><br>                    if R_freeInd_complex:<br>                        plt.figure(3)<br>                        mngr = plt.get_current_fig_manager()<br>                        mngr.window.setGeometry(450,25,400, 400)<br>                        plt.plot(range(0,numIterations),np.mean(Rfree_complex,axis=0))<br>                        plt.title("Mean R-free Value vs Iteration Number")<br>                        plt.xlabel("Iteration Num")<br>                        plt.ylabel('Mean R-free')<br>                        plt.draw()<br><br>                        plt.figure(4)<br>                        mngr = plt.get_current_fig_manager()<br>                        mngr.window.setGeometry(450,450,400, 400)<br>                        plt.hold(False)<br>                        X = np.linspace(0,1,np.shape(Rfree_complex)[0])<br>                        plt.plot(X, Rfree_complex[:,iterationNum-1])<br>                        plt.hold(False)<br>                        plt.title("Current Rfree Value vs Spatial Frequency")<br>                        plt.xlabel("Spatial Frequency (% of Nyquist)")<br>                        plt.ylabel('Rfree')<br>                        plt.draw()<br><br><br>                    plt.pause(1e-30) #forces display to update<br><br>        outputs['errK'] = errK<br>        if R_freeInd_complex:<br>            outputs['R_free'] = Rfree_complex<br>        outputs['reconstruction'] = np.fft.fftshift(outputs['reconstruction'])<br>        return outputs<br><br>    def generateKspaceIndices(obj):<br>        """<br>        * generateKspaceIndices *<br><br>        Maps the radial coordinate indices in the matrix obj<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br><br>        :param obj: Matrix of size to be mapped<br>        :return: 3D indices for each voxel in the volume<br>        """<br><br>        dims = np.shape(obj)<br>        if len(dims) < 3:<br>            dims = dims + (0,)<br><br>        if dims[0] % 2 == 0:<br>            ncK0 = dims[0]/2<br>            vec0 = np.arange(-ncK0, ncK0, 1)/ncK0<br>        elif dims[0] == 1:<br>            vec0 = 0<br>            ncK0 = 1<br><br>        else:<br>            ncK0 = ((dims[0]+1)/2)-1<br>            vec0 = np.arange(-ncK0, ncK0+1)/ncK0<br><br><br>        if dims[1] % 2 == 0:<br>            ncK1 = dims[1]/2<br>            vec1 = np.arange(-ncK1, ncK1, 1)/ncK1<br>        elif dims[1] == 1:<br>            vec1 = 0<br>            ncK1 = 1<br><br>        else:<br>            ncK1 = ((dims[1]+1)/2)-1<br>            vec1 = np.arange(-ncK1, ncK1+1)/ncK1<br><br><br>        if dims[2] % 2 == 0:<br>            ncK2 = dims[2]/2<br>            vec2 = np.arange(-ncK2, ncK2, 1)/ncK2<br>        elif dims[2] == 1:<br>            vec2 = 0<br>            ncK2 = 1<br><br>        else:<br>            ncK2 = ((dims[2]+1)/2)-1<br>            vec2 = np.arange(-ncK2, ncK2+1)/ncK2<br><br>        kx, ky, kz = np.meshgrid(vec1,vec0,vec2)<br>        Kindices = np.sqrt(kx**2 + ky**2 + kz**2)<br>        return Kindices<br><br><br><br><br><br><br>    def fillInFourierGrid(projections,angles,interpolationCutoffDistance):<br>        """<br>        * fillInFourierGrid *<br><br>        Primary function for converting a set of 2D projection images into a 3D Fourier grid<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param projections: N x N x num_projections NumPy array containing the projections<br>        :param angles: 3 x num_projections NumPy array of Euler angles phi,theta, psi<br>        :param interpolationCutoffDistance: Radius of interpolation kernel. Only values within this radius of a grid point are considered<br>        :return: the assembled Fourier grid<br><br>        """<br>        tic = time.time()<br>        dim1 = np.shape(projections)[0]<br>        dim2 = np.shape(projections)[1]<br>        if len(np.shape(projections))>2:<br>            numProjections = np.shape(projections)[2]<br>        else:<br>            numProjections = 1<br>        nc = np.round(dim1/2)<br>        n2 = nc<br>        measuredX = np.zeros([dim1*dim2,numProjections])<br>        measuredY = np.zeros([dim1*dim2,numProjections])<br>        measuredZ = np.zeros([dim1*dim2,numProjections])<br>        kMeasured = np.zeros([dim1,dim1,numProjections], dtype=complex)<br>        confidenceWeights = np.zeros([dim1,dim1,numProjections]) #do I need this??<br>        ky,kx = np.meshgrid(np.arange(-n2,n2,1),np.arange(-n2,n2,1))<br>        Q = np.sqrt(ky**2+kx**2)/n2<br>        kx = np.reshape(kx, [1, dim1*dim2], 'F')<br>        ky = np.reshape(ky, [1, dim1*dim2], 'F')<br>        kz = np.zeros([1, dim1*dim1])<br>        for projNum in range(0, numProjections):<br>            phi = angles[projNum, 0] * PI/180<br>            theta = angles[projNum, 1] * PI/180<br>            psi = angles[projNum, 2] * PI/180<br>            R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) ,np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>            [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>            [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br>            R = R.T<br><br>            Kcoordinates = np.zeros([3, dim1*dim2])<br>            Kcoordinates[0, :] = kx<br>            Kcoordinates[1, :] = ky<br>            Kcoordinates[2, :] = kz<br><br><br>            rotkCoords = np.dot(R, Kcoordinates)<br>            confidenceWeights[:, :, projNum] = np.ones_like(Q) #this implementation does not support individual projection weighting, so just set all weights to 1<br>            measuredX[:, projNum] = rotkCoords[0, :]<br>            measuredY[:, projNum] = rotkCoords[1, :]<br>            measuredZ[:, projNum] = rotkCoords[2, :]<br>            kMeasured[:, :, projNum] = np.fft.fftshift(np.fft.fftn(np.fft.ifftshift(projections[:, :, projNum])))<br><br>        measuredX = np.reshape(measuredX,[1, np.size(kMeasured)], 'F')<br>        measuredY = np.reshape(measuredY,[1, np.size(kMeasured)], 'F')<br>        measuredZ = np.reshape(measuredZ,[1, np.size(kMeasured)], 'F')<br>        kMeasured = np.reshape(kMeasured,[1, np.size(kMeasured)], 'F')<br>        confidenceWeights = np.reshape(confidenceWeights,[1, np.size(kMeasured)], 'F')<br>        notFlaggedIndices = kMeasured != -999<br>        measuredX = measuredX[notFlaggedIndices]<br>        measuredY = measuredY[notFlaggedIndices]<br>        measuredZ = measuredZ[notFlaggedIndices]<br>        kMeasured = kMeasured[notFlaggedIndices]<br>        confidenceWeights = confidenceWeights[notFlaggedIndices]<br><br>        masterInd = []<br>        masterVals = []<br>        masterDistances = []<br>        masterConfidenceWeights = []<br>        shiftMax = 0<br><br>        for Yshift in range(-shiftMax, shiftMax+1):<br>            for Xshift in range(-shiftMax, shiftMax+1):<br>                for Zshift in range(-shiftMax, shiftMax+1):<br><br>                    tmpX = np.round(measuredX) + Xshift<br>                    tmpY = np.round(measuredY) + Yshift<br>                    tmpZ = np.round(measuredZ) + Zshift<br><br><br>                    tmpVals = kMeasured<br>                    tmpConfidenceWeights = confidenceWeights<br>                    distances = np.sqrt(abs(measuredX-tmpX)**2 + abs(measuredY-tmpY)**2 + abs(measuredZ-tmpZ)**2)<br>                    tmpX+=nc<br>                    tmpY+=nc<br>                    tmpZ+=nc<br><br>                    goodInd = (np.logical_not((tmpX > (dim1-1)) | (tmpX < 0) | (tmpY > (dim1-1)) | (tmpY < 0) | (tmpZ > (dim1-1)) | (tmpZ < 0))) & (distances <= interpolationCutoffDistance)<br><br>                    masterInd=np.append(masterInd, np.ravel_multi_index((tmpX[goodInd].astype(np.int64), tmpY[goodInd].astype(np.int64), tmpZ[goodInd].astype(np.int64)),[dim1, dim1, dim1], order='F'))<br>                    masterVals=np.append(masterVals, tmpVals[goodInd])<br>                    masterDistances=np.append(masterDistances, distances[goodInd])<br>                    masterConfidenceWeights=np.append(masterConfidenceWeights, tmpConfidenceWeights[goodInd])<br><br><br>                    t = 0<br><br>        masterInd = np.array(masterInd).astype(np.int64)<br>        masterVals = np.array(masterVals)<br>        masterDistances = np.array(masterDistances)<br>        masterConfidenceWeights = np.array(masterConfidenceWeights)<br><br><br><br>        sortIndices = np.argsort(masterInd)<br>        masterInd = masterInd[sortIndices]<br>        masterVals = masterVals[sortIndices]<br>        masterDistances = masterDistances[sortIndices]<br>        masterConfidenceWeights = masterConfidenceWeights[sortIndices]<br><br><br>        halfwayCutoff = ((dim1+1)**3)//2+1<br><br><br>        masterVals = masterVals[masterInd <= halfwayCutoff]<br>        masterDistances = masterDistances[masterInd <= halfwayCutoff]<br>        masterConfidenceWeights = masterConfidenceWeights[masterInd <= halfwayCutoff]<br>        masterInd = masterInd[masterInd <= halfwayCutoff]<br><br><br>        uniqueVals, uniqueInd = np.unique(masterInd, return_index=True)<br><br>        uniqueInd = np.append(uniqueInd, 0)<br><br>        diffVec = np.diff(uniqueInd)<br>        singleInd = diffVec == 1<br>        multiInd = np.where(diffVec != 1)<br>        measuredK = np.zeros([dim1**3], dtype=complex)<br><br>        measuredK[uniqueVals[singleInd]] = masterVals[uniqueInd[0:-1][singleInd]]<br><br>        vals = weightValues.weightValue(np.array(multiInd[0][:],dtype=int), uniqueInd, masterDistances, masterVals)<br><br>        measuredK[uniqueVals[multiInd[0][:]]] = vals<br>        measuredK = np.reshape(measuredK,[dim1,dim1,dim1],order='F')<br><br>        # print ("time3 " , time.time()-tic3)<br>        measuredK[np.isnan(measuredK)] = 0<br>        measuredK = GENFIRE.utility.hermitianSymmetrize(measuredK)<br><br>        print ("Fourier grid assembled in %d seconds" % (time.time()-tic))<br>        return measuredK<br><br><br><br><br><br>    def readMAT(filename):<br>        """<br>        * readMAT *<br><br>        Read projections from a .mat file<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: MATLAB file (.mat) containing projections<br>        :return: NumPy array containing projections<br>        """<br><br>        try: #try to open the projections as a stack<br>            projections = scipy.io.loadmat(filename)<br>            projections = np.array(projections[projections.keys()[0]])<br>        except: ## -- figure out where error is thrown<br>             #check if the projections are in individual files<br>            flag = True<br>            filename_base, file_extension = os.path.splitext(filename)<br>            projectionCount = 1<br>            while flag: #first count the number of projections so the array can be initialized<br>                projectionCount = projectionCount<br>                nextFile = filename_base + str(projectionCount) + file_extension<br>                if os.path.isfile(nextFile):<br>                    projectionCount += 1<br>                else:<br>                    flag = False<br><br><br>            ## open first projection to get dimensions<br>            pj = scipy.io.loadmat(filename_base + str(1) + file_extension)<br>            pj = pj[projections.keys()[0]]<br>            dims = np.shape(pj)<br>            #initialize projection array<br>            projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>            #now actually load in the tiff images<br>            for projNum in range(projectionCount):<br>                nextFile = filename_base + str(projNum) + file_extension<br>                pj = scipy.io.loadmat(filename_base + str(projNum) + file_extension)<br>                pj = pj[pj.keys()[0]]<br>                projections[:, :, projNum] = np.array(pj)<br><br>        return projections<br><br><br>    def readTIFF(filename):<br>        """<br>        * readTIFF *<br><br>        Read (possibly multiple) TIFF images into a NumPy array<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: Name of TIFF file or TIFF file basename to read. If the filename is a base then<br>        #       the images must begin with the string contained in filename followed by consecutive integers with<br>        #       no zero padding, i.e. foo1.tiff, foo2.tiff,..., foo275.tiff<br>        :return: NumPy array containing projections<br>        """<br>        import functools<br>        from PIL import Image<br>        import os<br>        try:<br>            projections = np.array(Image.open(filename))<br>        except:<br>            flag = True<br>            filename_base, file_extension = os.path.splitext(filename)<br>            projectionCount = 1<br>            while flag: #first count the number of projections so the array can be initialized<br>                projectionCount = projectionCount<br>                nextFile = filename_base + str(projectionCount) + file_extension<br>                if os.path.isfile(nextFile):<br>                    projectionCount += 1<br>                else:<br>                    flag = False<br><br>            ## open first projection to get dimensions<br>            dims = np.shape(Image.open(filename_base + str(1) + file_extension))<br><br>            #initialize projection array<br>            projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>            pool = Pool(4)<br>            func = functools.partial(readInTiffProjection, filename_base)<br>            pj = pool.map(func, range(projectionCount))<br>            for j  in range(projectionCount):<br>                projections[:, :, j] = pj[j]<br>            return projections<br><br>    def readInTiffProjection(filename_base, fileNumber):<br>        """<br>        * readInTiffProjection *<br><br>        Reads and returns a single TIFF image as a NumPy array<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename_base: Base filename of TIFF<br>        :param fileNumber: Image number<br>        :return: Image in a 2D NumPy array<br>        """<br>        from PIL import Image<br>        nextFile = filename_base + str(fileNumber) + '.tif'<br>        return np.array(Image.open(nextFile))<br><br>    def readMRC(filename, dtype=float,order="C"):<br>        """<br>        * readMRC *<br><br>        Read in a volume in .mrc file format. See http://bio3d.colorado.edu/imod/doc/mrc_format.txt<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: Filename of .mrc<br>        :return: NumPy array containing the .mrc data<br>        """<br>        import struct<br>        headerIntNumber = 56<br>        sizeof_int = 4<br>        headerCharNumber = 800<br>        sizeof_char = 1<br>        with open(filename,'rb') as fid:<br>            int_header = struct.unpack('=' + 'i'*headerIntNumber, fid.read(headerIntNumber * sizeof_int))<br>            char_header = struct.unpack('=' + 'c'*headerCharNumber, fid.read(headerCharNumber * sizeof_char))<br>            dimx, dimy, dimz, data_flag= int_header[:4]<br>            print "reading, ", dimx,dimy,dimz<br>            if (data_flag == 0):<br>                datatype='u1'<br>            elif (data_flag ==1):<br>                datatype='i1'<br>            elif (data_flag ==2):<br>                datatype='f4'<br>            elif (data_flag ==3):<br>                datatype='c'<br>            elif (data_flag ==4):<br>                datatype='f4'<br>            elif (data_flag ==6):<br>                datatype='u2'<br>            else:<br>                raise ValueError("No supported datatype found!\n")<br>            print dimx,dimy,dimz<br>            print datatype<br>            return np.fromfile(file=fid, dtype=datatype,count=dimx*dimy*dimz).reshape((dimx,dimy,dimz),order=order).astype(dtype)<br><br>    def writeMRC(filename, arr, datatype='f4'):<br>        """<br>        * writeMRC *<br><br>        Write a volume to .mrc file format. See http://bio3d.colorado.edu/imod/doc/mrc_format.txt<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved<br><br>        :param filename: Filename of .mrc file to write<br>        :param arr: NumPy volume of data to write<br>        :param dtype: Type of data to write<br>        """<br>        dimx, dimy, dimz = np.shape(arr)<br>        if datatype != arr.dtype:<br>            arr = arr.astype(datatype)<br>        int_header = np.zeros(56,dtype='int32')<br><br>        if (datatype == 'u1'):<br>            data_flag = 0<br>        elif (datatype =='i1'):<br>            data_flag = 1<br>        elif (datatype =='f4'):<br>            data_flag = 2<br>        elif (datatype =='c'):<br>            data_flag = 3<br>        elif (datatype =='f4'):<br>            data_flag = 4<br>        elif (datatype =='u2'):<br>            data_flag = 6<br>        else:<br>            raise ValueError("No supported datatype found!\n")<br><br>        int_header[:4] = (dimx,dimy,dimz,data_flag)<br>        char_header = str(' '*800)<br>        with open(filename,'wb') as fid:<br>            fid.write(int_header.tobytes())<br>            fid.write(char_header)<br>            fid.write(arr.tobytes())<br><br><br><br>    class DisplayFigure:<br>        """<br>        * DisplayFigure *<br><br>        Helper class for displaying figures during reconstruction process<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br>        """<br>        def __init__(self):<br>            self.DisplayFigureON = False<br>            self.DisplayErrorFigureON = False<br>            self.displayFrequency = 5<br>            self.reconstructionDisplayWindowSize = 0<br><br><br><br>class ReconstructionParameters():<br><br>    """<br>    Helper class for containing reconstruction parameters<br>    """<br>    _supportedFiletypes = ['.tif', '.mrc', '.mat', '.npy']<br>    _supportedAngleFiletypes = ['.txt', '.mat', '.npy']<br>    def __init__(self):<br>        self.projectionFilename = ""<br>        self.angleFilename = ""<br>        self.supportFilename = ""<br>        self.resolutionExtensionSuppressionState = 1 #1 for resolution extension/suppression, 2 for off, 3 for just extension<br>        self.numIterations = 50<br>        self.displayFigure = DisplayFigure()<br>        self.oversamplingRatio = 3<br>        self.interpolationCutoffDistance = 0.7<br>        self.isInitialObjectDefined = False<br>        self.resultsFilename = os.path.join(os.getcwd(), 'results.mrc')<br>        self.useDefaultSupport = True<br>        self.calculateRfree = True<br>        self.initialObjectFilename = None<br>    def checkParameters(self): #verify file extensions are supported<br>        parametersAreGood = 1<br><br>        projection_extension = os.path.splitext(self.projectionFilename)<br>        if projection_extension[1] not in ReconstructionParameters._supportedFiletypes:<br>            parametersAreGood = 0<br><br>        angle_extension = os.path.splitext(self.angleFilename)<br>        if angle_extension[1] not in ReconstructionParameters._supportedAngleFiletypes:<br>            parametersAreGood = 0<br><br>        if self.supportFilename != "": #empty support filename is okay, as this will trigger generation of a default support<br>            support_extension = os.path.splitext(self.supportFilename)<br>            if support_extension[1] not in ReconstructionParameters._supportedFiletypes:<br>                parametersAreGood = 0<br><br>        if not self.getResultsFilename():<br>            parametersAreGood = 0<br>        return parametersAreGood<br><br>    # Define setters/getters<br>    def setProjectionFilename(self, projectionFilename):<br>        if projectionFilename:<br>            self.projectionFilename = os.path.join(os.getcwd(), unicode(projectionFilename.toUtf8(), encoding='UTF-8'))<br><br>    def getProjectionFilename(self):<br>        return self.projectionFilename<br><br>    def setAngleFilename(self, angleFilename):<br>        if angleFilename:<br>            self.angleFilename = os.path.join(os.getcwd(), unicode(angleFilename.toUtf8(), encoding='UTF-8'))<br><br>    def getAngleFilename(self):<br>        return self.angleFilename<br><br>    def setSupportFilename(self, supportFilename):<br>        if supportFilename:<br>            self.supportFilename = os.path.join(os.getcwd(), unicode(supportFilename.toUtf8(), encoding='UTF-8'))<br><br>    def getSupportFilename(self):<br>        return self.supportFilename<br><br>    def setResultsFilename(self, resultsFilename):<br>        if resultsFilename:<br>            self.resultsFilename = os.path.join(os.getcwd(), unicode(resultsFilename.toUtf8(), encoding='UTF-8'))<br><br>    def getResultsFilename(self):<br>        return self.resultsFilename<br><br><br>    def setInitialObjectFilename(self, initialObjectFilename):<br>        self.initialObjectFilename = os.path.join(os.getcwd(), unicode(initialObjectFilename.toUtf8(), encoding='UTF-8'))<br>        self.isInitialObjectDefined = True<br><br>    def getInitialObjectFilename(self):<br>        if self.CheckIfInitialObjectIsDefined():<br>            return self.initialObjectFilename<br>        else:<br>            pass<br><br>    def CheckIfInitialObjectIsDefined(self):<br>        return self.isInitialObjectDefined<br><br>    def setResolutionExtensionSuppressionState(self, state):<br>        self.resolutionExtensionSuppressionState = state<br><br>    def getResolutionExtensionSuppressionState(self):<br>        return self.resolutionExtensionSuppressionState<br><br>    def setNumberOfIterations(self,numIterations):<br>        numIterations = numIterations.toInt()<br>        if numIterations[1]:<br>            numIterations = numIterations[0]<br>            if numIterations > 0:<br>                self.numIterations = numIterations<br><br>    def getNumberOfIterations(self):<br>        return self.numIterations<br><br>    def toggleDisplayFigure(self): # whether or not to display figure during reconstruction<br>        if self.displayFigure.DisplayFigureON:<br>            self.displayFigure.DisplayFigureON = False<br>        else:<br>            self.displayFigure.DisplayFigureON = True<br><br>        if self.displayFigure.DisplayErrorFigureON:<br>            self.displayFigure.DisplayErrorFigureON = False<br>        else:<br>            self.displayFigure.DisplayErrorFigureON = True<br><br>    def getDisplayFigure(self):<br>        return self.displayFigure<br><br>    def setOversamplingRatio(self, oversamplingRatio):<br>        self.oversamplingRatio = oversamplingRatio.toInt()[0]<br><br>    def getOversamplingRatio(self):<br>        return self.oversamplingRatio<br><br>    def setInterpolationCutoffDistance(self, interpolationCutoffDistance):<br>        self.interpolationCutoffDistance = interpolationCutoffDistance.toFloat()[0]<br><br>    def getInterpolationCutoffDistance(self):<br>        return self.interpolationCutoffDistance<br></code></body>
    </html>