<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>../timing</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><font color="green">from</font> __future__ <font color="green">import</font> division<br><font color="green">import</font> numpy as np<br><font color="green">import</font> matplotlib<br>matplotlib.use("Qt4Agg")<br><font color="green">import</font> matplotlib.pyplot as plt<br><font color="green">import</font> scipy.fftpack as sfft<br><font color="green">import</font> os<br><font color="green">import</font> scipy.io as io<br><font color="green">import</font> pyfftw<br><font color="green">import</font> time<br><font color="green">import</font> GENFIRE_<font color="green">from</font>_GUI_Input<br><font color="green">import</font> misc<br><font color="green">import</font> itertools<br><font color="green">from</font> multiprocessing <font color="green">import</font> Pool,Array<br>PI = 3.14159265359<br><br><font color="green">def</font> fillInFourierGrid(projections,angles,interpolationCutoffDistance):<br>        print("correct version")<br>        # <font color="green">import</font> time<br>        tic1 = time.time()<br>        # print angles<br>        dim1 = np.shape(projections)[0]<br>        dim2 = np.shape(projections)[1]<br>        <font color="green">if</font> len(np.shape(projections))>2:<br>            numProjections = np.shape(projections)[2]<br>        else:<br>            numProjections = 1<br>        # print np.shape(projections)<br>        nc = np.round(dim1/2)<br>        n2 = nc<br>        # measuredY = zeros(1,size(projections,2)*size(projections,1),size(projections,3),'single');<br>        measuredX = np.zeros([dim1*dim2,numProjections])<br>        measuredY = np.zeros([dim1*dim2,numProjections])<br>        measuredZ = np.zeros([dim1*dim2,numProjections])<br>        kMeasured = np.zeros([dim1,dim1,numProjections], dtype=complex)<br>        confidenceWeights = np.zeros([dim1,dim1,numProjections]) #do I need this??<br>        # print "shape angles" ,np.shape(angles)<br>        ky,kx = np.meshgrid(np.arange(-n2,n2,1),np.arange(-n2,n2,1))<br>        Q = np.sqrt(ky**2+kx**2)/n2<br>        kx = np.reshape(kx, [1, dim1*dim2], 'F')<br>        ky = np.reshape(ky, [1, dim1*dim2], 'F')<br>        kz = np.zeros([1, dim1*dim1])<br>        <font color="green">for</font> projNum in range(0, numProjections):<br>        #<font color="green">for</font> projNum in range(0,1):<br>            # print "projNum", projNum<br>            phi = angles[0, projNum] * PI/180<br>            theta = angles[1, projNum] * PI/180<br>            psi = angles[2, projNum] * PI/180<br>            R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) ,np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>            [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>            [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br>            R = R.T<br>            # print R<br><br>            # print np.shape(kx)<br>            # print np.shape(kz)<br><br>            Kcoordinates = np.zeros([3, dim1*dim2])<br>            Kcoordinates[0, :] = kx<br>            Kcoordinates[1, :] = ky<br>            Kcoordinates[2, :] = kz<br><br>            # print kx[0,0:5]<br>            # print ky[0,0:5]<br>            # print np.shape(Kcoordinates)<br>            #<br>            # print Kcoordinates[0,0:5]<br>            # print Kcoordinates[1,0:5]<br>            # print Kcoordinates[2,0:5]<br>            rotkCoords = np.dot(R, Kcoordinates)<br>            # print rotkCoords[0, :]<br>            # print np.shape(Q)<br>            confidenceWeights[:, :, projNum] = np.ones_like(Q) #this implementation does not support individual projection weighting, so just set all weights to 1<br>            measuredX[:, projNum] = rotkCoords[0, :]<br>            measuredY[:, projNum] = rotkCoords[1, :]<br>            measuredZ[:, projNum] = rotkCoords[2, :]<br>            # print np.shape(np.fft.fftn(projections[:, :, projNum]))<br>            kMeasured[:, :, projNum] = np.fft.fftsh<font color="green">if</font>t(np.fft.fftn(np.fft.<font color="green">if</font>ftsh<font color="green">if</font>t(projections[:, :, projNum])))<br>            # print kMeasured[0,0,0]<br>            # print kMeasured[1,0,0]<br>            # print 1/n2<br>            # print ky[0:5,0:5]<br><br>        # del projections, rotkCoords<br>        # print np.size(measuredX)<br>        measuredX = np.reshape(measuredX,[1, np.size(kMeasured)], 'F')<br>        measuredY = np.reshape(measuredY,[1, np.size(kMeasured)], 'F')<br>        measuredZ = np.reshape(measuredZ,[1, np.size(kMeasured)], 'F')<br>        kMeasured = np.reshape(kMeasured,[1, np.size(kMeasured)], 'F')<br>        confidenceWeights = np.reshape(confidenceWeights,[1, np.size(kMeasured)], 'F')<br>        notFlaggedIndices = kMeasured != -999<br>        measuredX = measuredX[notFlaggedIndices]<br>        measuredY = measuredY[notFlaggedIndices]<br>        measuredZ = measuredZ[notFlaggedIndices]<br>        kMeasured = kMeasured[notFlaggedIndices]<br>        confidenceWeights = confidenceWeights[notFlaggedIndices]<br><br>        masterInd = []<br>        masterVals = []<br>        masterDistances = []<br>        masterConfidenceWeights = []<br>        # sh<font color="green">if</font>tMax = int(round(interpolationCutoffDistance))<br>        sh<font color="green">if</font>tMax = 0<br><br>        print ("time 1" , time.time()-tic1)<br>        tic2 = time.time()<br>        <font color="green">for</font> Ysh<font color="green">if</font>t in range(-sh<font color="green">if</font>tMax, sh<font color="green">if</font>tMax+1):<br>            <font color="green">for</font> Xsh<font color="green">if</font>t in range(-sh<font color="green">if</font>tMax, sh<font color="green">if</font>tMax+1):<br>                <font color="green">for</font> Zsh<font color="green">if</font>t in range(-sh<font color="green">if</font>tMax, sh<font color="green">if</font>tMax+1):<br><br>                    tmpX = np.round(measuredX) + Xsh<font color="green">if</font>t<br>                    tmpY = np.round(measuredY) + Ysh<font color="green">if</font>t<br>                    tmpZ = np.round(measuredZ) + Zsh<font color="green">if</font>t<br><br><br>                    tmpVals = kMeasured<br>                    tmpConfidenceWeights = confidenceWeights<br>                    distances = np.sqrt(abs(measuredX-tmpX)**2 + abs(measuredY-tmpY)**2 + abs(measuredZ-tmpZ)**2)<br>                    tmpX+=nc<br>                    tmpY+=nc<br>                    tmpZ+=nc<br><br>                    goodInd = (np.logical_not((tmpX > (dim1-1)) | (tmpX < 0) | (tmpY > (dim1-1)) | (tmpY < 0) | (tmpZ > (dim1-1)) | (tmpZ < 0))) & (distances <= interpolationCutoffDistance)<br>                    # masterInd+=np.ravel_multi_index((tmpX[goodInd], tmpY[goodInd], tmpZ[goodInd]),[dim1, dim1, dim1], order='F')<br>                    # masterVals+=tmpVals[goodInd]<br>                    # masterDistances+=distances[goodInd]<br>                    # masterConfidenceWeights+=tmpConfidenceWeights[goodInd]<br>                    # print (tmpX[goodInd], tmpY[goodInd], tmpZ[goodInd])<br>                    # print np.ravel_multi_index((tmpX[goodInd].astype(np.int64), tmpY[goodInd].astype(np.int64), tmpZ[goodInd].astype(np.int64)),[dim1, dim1, dim1], order='F')<br>                    # masterInd+=np.ndarray.tolist(np.ravel_multi_index((tmpX[goodInd].astype(np.int64), tmpY[goodInd].astype(np.int64), tmpZ[goodInd].astype(np.int64)),[dim1, dim1, dim1], order='F'))<br>                    # # masterInd+=np.ndarray.tolist(np.ravel_multi_index((tmpX[goodInd], tmpY[goodInd], tmpZ[goodInd]),[dim1, dim1, dim1], order='F'))<br>                    # masterVals+=np.ndarray.tolist(tmpVals[goodInd])<br>                    # masterDistances+=np.ndarray.tolist(distances[goodInd])<br>                    # masterConfidenceWeights+=np.ndarray.tolist(tmpConfidenceWeights[goodInd])<br><br>                    masterInd=np.append(masterInd, np.ravel_multi_index((tmpX[goodInd].astype(np.int64), tmpY[goodInd].astype(np.int64), tmpZ[goodInd].astype(np.int64)),[dim1, dim1, dim1], order='F'))<br>                    masterVals=np.append(masterVals, tmpVals[goodInd])<br>                    masterDistances=np.append(masterDistances, distances[goodInd])<br>                    masterConfidenceWeights=np.append(masterConfidenceWeights, tmpConfidenceWeights[goodInd])<br><br><br>                    # print goodInd[0:60]<br>                    t = 0;<br><br>        masterInd = np.array(masterInd).astype(np.int64)<br>        masterVals = np.array(masterVals)<br>        masterDistances = np.array(masterDistances)<br>        masterConfidenceWeights = np.array(masterConfidenceWeights)<br><br><br><br>        sortIndices = np.argsort(masterInd)<br>        masterInd = masterInd[sortIndices]<br>        masterVals = masterVals[sortIndices]<br>        masterDistances = masterDistances[sortIndices]<br>        masterConfidenceWeights = masterConfidenceWeights[sortIndices]<br>        # tmp2 = masterInd[sortIndices]<br><br><br>        halfwayCutoff = ((dim1+1)**3)//2+1<br><br><br>        masterVals = masterVals[masterInd <= halfwayCutoff]<br>        masterDistances = masterDistances[masterInd <= halfwayCutoff]<br>        masterConfidenceWeights = masterConfidenceWeights[masterInd <= halfwayCutoff]<br>        masterInd = masterInd[masterInd <= halfwayCutoff]<br><br><br>        uniqueVals, uniqueInd = np.unique(masterInd, return_index=True)<br><br>        uniqueInd = np.append(uniqueInd, 0)<br><br>        d<font color="green">if</font>fVec = np.d<font color="green">if</font>f(uniqueInd)<br>        singleInd = d<font color="green">if</font>fVec == 1<br>        # multiInd = d<font color="green">if</font>fVec != 1<br>        multiInd = np.where(d<font color="green">if</font>fVec != 1)<br>        # print masterInd[multiInd[0][0]-2:multiInd[0][0]+3]<br>        # measuredK = np.zeros([dim1, dim1, dim1], dtype=complex)<br>        measuredK = np.zeros([dim1**3], dtype=complex)<br><br>        # singleIndtoXYZ = np.unravel_index(uniqueVals[singleInd], [dim1, dim1, dim1], order='F')<br>        measuredK[uniqueVals[singleInd]] = masterVals[uniqueInd[0:-1][singleInd]]<br><br><br>        print ("time 2 ", time.time()-tic2)<br>        tic3 = time.time()<br>        tic3 = time.time()<br>        t1 = time.time()<br># ####<br>#         <font color="green">def</font> weightValue(index):<br>#             ind = multiInd[0][index]<br>#             indVector = range(uniqueInd[ind],uniqueInd[ind+1])<br>#             distances = np.array(masterDistances[indVector]+1e-10)<br>#             complexVals = masterVals[indVector]<br>#             sumDistances = np.sum(distances)<br>#             weights = (((1/distances)*sumDistances) / (np.sum(1/distances)*sumDistances))<br>#             voxel_Mag = np.sum(weights*abs(complexVals))<br>#             voxel_Phase = np.sum(weights*complexVals)<br>#             return voxel_Mag*voxel_Phase/abs(voxel_Phase)<br><br>        <font color="green">def</font> weightValue(index):<br>            ind = multiInd[0][index]<br>            indVector = range(uniqueInd[ind],uniqueInd[ind+1])<br>            distances = np.array(masterDistances[indVector]+1e-10)<br>            complexVals = masterVals[indVector]<br>            sumDistances = np.sum(distances)<br>            weights = (((1/distances)*sumDistances) / (np.sum(1/distances)*sumDistances))<br>            voxel_Mag = np.sum(weights*abs(complexVals))<br>            voxel_Phase = np.sum(weights*complexVals)<br>            return voxel_Mag*voxel_Phase/abs(voxel_Phase)<br><br>        # <font color="green">for</font> index in range(0,np.size(multiInd)):<br>        #     weightValue(index)<br>        #<br>        # debugFile = {'mk': measuredK}<br>        # scipy.io.savemat('debug.mat',debugFile)<br>        # vals = np.array(list(itertools.imap(weightValue,np.arange(0,np.size(multiInd)))))<br>        # v = list(vals)<br>        #<br>        # pool = Pool(processes=1)<br>        # multiInd = Array('d',multiInd)<br>        # results = pool.map(weightValue, np.arange(0,np.size(multiInd)))<br>        # results = pool.map()<br>        #<br>        # outputs = [results[0] <font color="green">for</font> result in results]<br>        # print "HERE,", np.shape(outputs)<br><br>        time5 = time.time()<br>        vals = list(itertools.imap(weightValue,np.arange(0,np.size(multiInd))))<br>        print "BIG TIME2, " ,time.time()-time5<br>        testTime = time.time()<br>        # bigTime = time.time()<br>        measuredK[uniqueVals[multiInd[0][:]]] = vals<br>        # print "INDEX TIME", time.time()-bigTime<br>        measuredK = np.reshape(measuredK,[dim1,dim1,dim1],order='F')<br><br>        print ("time3 " , time.time()-tic3)<br>        measuredK[np.isnan(measuredK)] = 0<br>        measuredK = misc.hermitianSymmetrize(measuredK)<br><br>        print ("GENFIRE: Fourier grid assembled in %d seconds" % (time.time()-tic1))<br>        return measuredK<br><br>projections = io.loadmat('projections.mat')['projections']<br>dims = np.shape(projections)<br>paddedDim = dims[0] * 3<br>padding = int((paddedDim-dims[0])/2)<br>projections = np.pad(projections,((padding,padding),(padding,padding),(0,0)),'constant')<br>angles = io.loadmat('angles.mat')['angles']<br>icd = 0.7<br>fillInFourierGrid(projections,angles,icd)<br># print locals()<br></code></body>
    </html>