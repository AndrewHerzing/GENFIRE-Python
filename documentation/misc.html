<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>../misc</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code><font color="green">from</font> __future__ <font color="green">import</font> division<br><font color="green">import</font> numpy as np<br><font color="green">import</font> pyfftw<br><font color="green">import</font> matplotlib.pyplot as plt<br><font color="green">from</font> scipy <font color="green">import</font> io<br><font color="green">from</font> scipy.interpolate <font color="green">import</font> RegularGridInterpolator<br><font color="green">import</font> time<br>PI = 3.14159265359<br><br><br><br>## hermitianSymmetrize ##<br><br>## Applies Hermitian symmetry to "input". If one symmetry mate is not equal to the complex conjugate of the other<br>## their average is taken. If only one of them exists (is nonzero), then the one value is used. If neither exists<br>## the value remains 0. In terms of implementation, this function produces Hermitian symmetry by adding the object<br>## to its complex conjugate with the indices reversed. This requires the array to be odd, so there is also a check<br>## to make the array odd and then take back the original size at the end, <font color="green">if</font> necessary.<br><br>## Author: AJ Pryor<br>## Jianwei (John) Miao Coherent Imaging Group<br>## University of Cali<font color="green">for</font>nia, Los Angeles<br>## Copyright (c) 2016. All Rights Reserved.<br><font color="green">def</font> hermitianSymmetrize(input):<br><br>    startDims = np.shape(input) # initial dimensions<br><br>    # remember the initial dimensions <font color="green">for</font> the end<br>    dimx = startDims[0]<br>    dimy = startDims[1]<br>    dimz = startDims[2]<br>    flag = False # flag to trigger copying to new odd dimensioned array<br><br>    #check <font color="green">if</font> any dimension is odd<br>    <font color="green">if</font> dimx % 2 == 0:<br>        dimx += 1<br>        flag = True<br><br>    <font color="green">if</font> dimy % 2 == 0:<br>        dimy += 1<br>        flag = True<br><br>    <font color="green">if</font> dimz % 2 == 0:<br>        dimz += 1<br>        flag = True<br><br>    <font color="green">if</font> flag: # <font color="green">if</font> any dimensions are even, create a new with all odd dimensions and copy input<br>        newInput = np.zeros((dimx,dimy,dimz), dtype=complex) #new array<br>        newInput[:startDims[0], :startDims[1], :startDims[2]] = input # copy values<br>        numberOfValues = (newInput != 0).astype(float) #track number of values <font color="green">for</font> averaging<br>        newInput = newInput + np.conj(newInput[::-1, ::-1, ::-1]) # combine Hermitian symmetry mates<br>        numberOfValues = numberOfValues + numberOfValues[::-1, ::-1, ::-1] # track number of points included in each sum<br><br>        newInput[numberOfValues != 0] /= numberOfValues[numberOfValues != 0] # take average where two values existed<br>        newInput[np.isnan(newInput)] = 0 # Shouldn't be any nan, but just to be safe<br><br>        debug = {'numberOfValues':numberOfValues,'newInput':newInput}<br>        io.savemat('debugging',debug)<br>        return newInput[:startDims[0], :startDims[1], :startDims[2]] # return original dimensions<br><br><br>    else: # otherwise, save your<font color="green">self</font> the trouble of copying the matrix over. See previous comments <font color="green">for</font> line-by-line<br>        numberOfValues = (input != 0).astype(int)<br>        input += np.conjugate(input[::-1, ::-1, ::-1])<br>        numberOfValues += numberOfValues[::-1, ::-1, ::-1]<br>        input[numberOfValues != 0] /= numberOfValues[numberOfValues != 0]<br>        input[np.isnan(input)] = 0<br>        return input<br><br><br><br><br>## smooth3D ##<br><br>## Smooths the real space object "object" by applying a Gaussian filter with standard<br>## deviation determined by "resolutionCutoff" which is a parameter expressed as a fraction<br>## of Nyquist frequency that determines the point at which the Gaussian filter decreases<br>## by 1/e<br><br>## Author: AJ Pryor<br>## Jianwei (John) Miao Coherent Imaging Group<br>## University of Cali<font color="green">for</font>nia, Los Angeles<br>## Copyright (c) 2016. All Rights Reserved.<br><br><font color="green">def</font> smooth3D(object,resolutionCutoff):<br>    dims = np.shape(object)<br>    <font color="green">if</font> dims[2] == 1:<br>        raise Exception('This is not a 3D object, use smooth2D instead.')<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # These  next few lines are easier to read, but in the actual code I just directly<br>    # place the np.arange terms in to avoid creating unnecessary variables<br>    # Xvec = np.arange(0,dims[0])-Xcenter<br>    # Yvec = np.arange(0,dims[1])-Ycenter<br>    # Zvec = np.arange(0,dims[2])-Zcenter<br>    # xx, yy, zz = np.meshgrid(Xvec, Yvec, Zvec)<br><br>    xx, yy, zz = np.meshgrid(np.arange(0,dims[0])-Xcenter, np.arange(0,dims[1])-Ycenter, np.arange(0,dims[2])-Zcenter)<br>    sigma  = dims[0]/2*resolutionCutoff<br><br>    #construct the filter and normalize<br>    K_filter = np.exp(-(((xx)**2 + (yy)**2 + (zz) **2)/(2*sigma*sigma)))<br>    K_filter /= np.max(np.max(np.max(abs(K_filter))))<br><br>    # take FFT and multiply by filter<br>    kbinned = pyfftw.interfaces.numpy_fft.fftsh<font color="green">if</font>t(pyfftw.interfaces.numpy_fft.fftn(object,overwrite_input=True)) * K_filter<br><br>    # Assuming the input is real, the output will be approximately real, but will have some<br>    # tiny imaginary part due to rounding errors. This function would work <font color="green">for</font> smoothing a<br>    # complex object, but this return statement would need to be mod<font color="green">if</font>ied<br>    return np.real(pyfftw.interfaces.numpy_fft.<font color="green">if</font>ftn(pyfftw.interfaces.numpy_fft.<font color="green">if</font>ftsh<font color="green">if</font>t(kbinned)))<br><br><br><br>## smooth2D ##<br><br>## Smooths the 2D real space object "object" by applying a Gaussian filter with standard<br>## deviation determined by "resolutionCutoff" which is a parameter expressed as a fraction<br>## of Nyquist frequency that determines the point at which the Gaussian filter decreases<br>## by 1/e<br><br>## Author: AJ Pryor<br>## Jianwei (John) Miao Coherent Imaging Group<br>## University of Cali<font color="green">for</font>nia, Los Angeles<br>## Copyright (c) 2016. All Rights Reserved.<br><br><font color="green">def</font> smooth2D(object,resolutionCutoff):<br>    dims = np.shape(object)<br>    <font color="green">if</font> len(dims)>2:<br>        raise Exception('This is a 3D object, use smooth3D instead.')<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br><br>    # These  next few lines are easier to read, but in the actual code I just directly<br>    # place the np.arange terms in to avoid creating unnecessary variables<br>    # Xvec = np.arange(0,dims[0])-Xcenter<br>    # Yvec = np.arange(0,dims[1])-Ycenter<br>    # xx, yy = np.meshgrid(Xvec, Yvec)<br><br>    xx, yy = np.meshgrid(np.arange(0,dims[0])-Xcenter, np.arange(0,dims[1])-Ycenter)<br>    sigma  = dims[0]/2*resolutionCutoff<br><br>    #construct the filter and normalize<br>    K_filter = np.exp(-(((xx)**2 + (yy)**2)/(2*sigma*sigma)))<br>    K_filter /= np.max(np.max(np.max(abs(K_filter))))<br><br>    # take FFT and multiply by filter<br>    kbinned =  pyfftw.interfaces.numpy_fft.fftsh<font color="green">if</font>t(pyfftw.interfaces.numpy_fft.fftn(object,overwrite_input=True)) * K_filter<br><br>    # Assuming the input is real, the output will be approximately real, but will have some<br>    # tiny imaginary part due to rounding errors. This function would work <font color="green">for</font> smoothing a<br>    # complex object, but this return statement would need to be mod<font color="green">if</font>ied<br>    return np.real(pyfftw.interfaces.numpy_fft.<font color="green">if</font>ftn(pyfftw.interfaces.numpy_fft.<font color="green">if</font>ftsh<font color="green">if</font>t(kbinned)))<br><br><br><br><font color="green">def</font> calculateProjection_interp(modelK, phi, theta, psi):<br><br>    # projection = None<br>    dims = np.shape(modelK)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # X, Y, Z = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), 0)<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    # build coordinates of 3D FFT<br>    # kx, ky, kz = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), np.arange(1,dims[2]-Zcenter))<br><br>    kx = np.arange(0, dims[0])-Xcenter<br>    ky = np.arange(0, dims[1])-Ycenter<br>    kz = np.arange(0, dims[2])-Zcenter<br><br>    # construct interpolator function that does the actual computation<br>    interpolator = RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br><br>    # build coordinates of the slice we want to calculate<br>    kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(kx_slice)])<br>    rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>    rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>    rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    projection = interpolator(rotKCoords.T)<br>    projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br><br><br>    return np.real(pyfftw.interfaces.numpy_fft.fftsh<font color="green">if</font>t(pyfftw.interfaces.numpy_fft.<font color="green">if</font>ftn(pyfftw.interfaces.numpy_fft.<font color="green">if</font>ftsh<font color="green">if</font>t(projection))))<br><br><font color="green">def</font> calculateProjection_interp_pyfftw(modelK, phi, theta, psi):<br><br>    # projection = None<br>    dims = np.shape(modelK)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # X, Y, Z = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), 0)<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    # build coordinates of 3D FFT<br>    # kx, ky, kz = np.meshgrid(np.arange(1,dims[0]-Xcenter), np.arange(1,dims[1]-Ycenter), np.arange(1,dims[2]-Zcenter))<br><br>    kx = np.arange(0, dims[0])-Xcenter<br>    ky = np.arange(0, dims[1])-Ycenter<br>    kz = np.arange(0, dims[2])-Zcenter<br><br>    # construct interpolator function that does the actual computation<br>    interpolator = RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br><br>    # build coordinates of the slice we want to calculate<br>    kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(kx_slice)])<br>    rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>    rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>    rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    projection = interpolator(rotKCoords.T)<br>    projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br><br><br>    return np.real( pyfftw.interfaces.numpy_fft.fftsh<font color="green">if</font>t( pyfftw.interfaces.numpy_fft.<font color="green">if</font>ftn( pyfftw.interfaces.numpy_fft.<font color="green">if</font>ftsh<font color="green">if</font>t(projection))))<br><br></code></body>
    </html>